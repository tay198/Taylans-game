<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"> <title>Evidence Lockdown: Sector Scan (V4.0 Proto) </title>
  <style>
    /* Font-Face Load Issue: Temporarily removed @font-face for 'PoliceTech' to avoid FOUT
       If you have the font files, re-add the block like this:
    @font-face {
      font-family: 'PoliceTech';
      src: url('fonts/police-tech-font.woff2') format('woff2'),
           url('fonts/police-tech-font.woff') format('woff');
      font-display: swap;
    }
    */

    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      color: #E0E0E0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      /* Fallback fonts since PoliceTech is removed for now */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      cursor: default;
      background-color: #000;
    }

    #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    canvas {
      display: block;
      /* Canvas Z-Index Bug Fix */
      position: absolute;
      left: 0; /* Ensure it fills container if gameContainer is the direct parent */
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4); /* Kept shadow, might need adjustment if it looks off with z-index */
      /* UX Enhancements: Custom Cursor */
      touch-action: none; /* Already managed by JS init, but good for CSS too */
      pointer-events: auto; /* Default, but explicit */
    }

    .police-tape {
      position: absolute; /* Will be placed inside gameContainer via JS/HTML change if not already */
      background-image: repeating-linear-gradient(
        45deg,
        #ffd700,
        #ffd700 20px,
        #333 20px,
        #333 40px
      );
      color: #000;
      font-weight: bold;
      text-align: center;
      font-size: 1.5vw;
      line-height: 3vw;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      z-index: 2; /* Above canvas(0) and wanted posters(1) */
      pointer-events: none; /* UX Enhancements: Interactive Layers Block Taps */
    }
    .police-tape-top, .police-tape-bottom { width: 100%; height: 3vw; left: 0; }
    .police-tape-left, .police-tape-right { height: 100%; width: 3vw; top: 0; writing-mode: vertical-rl; text-orientation: mixed; }
    .police-tape-top { top: 0; }
    .police-tape-bottom { bottom: 0; }
    .police-tape-left { left: 0; }
    .police-tape-right { right: 0; }

    #wantedPosterContainer {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; /* Already had this, which is correct */
        overflow: hidden;
        z-index: 1; /* Above canvas(0) */
    }

    .wanted-poster {
        position: absolute;
        /* Poster Responsiveness */
        width: clamp(80px, 20vw, 160px);
        font-size: clamp(10px, 2vw, 16px);
        aspect-ratio: 0.7; /* Maintain aspect ratio */
        background-color: #f0e6d2;
        border: 5px solid #5c3a21;
        box-shadow: 5px 5px 10px rgba(0,0,0,0.5);
        padding: 8px;
        text-align: center;
        font-family: 'Times New Roman', serif; /* Fallback if PoliceTech not available */
        color: #333;
        opacity: 0.7;
        /* pointer-events: none; -- Handled by container */
    }
    .wanted-poster h3 { margin: 0 0 5px 0; font-size: 1.1em; /* slightly larger for name */ color: #000;}
    .wanted-poster img { width: 80%; margin-bottom: 5px; border: 1px solid #333;}
    .wanted-poster p { margin: 0; font-size: 0.9em;} /* For reason text */

    .footer-credit { /* UX Enhancements: Attribution */
      position: absolute;
      bottom: 5px;
      width: 100%;
      text-align: center;
      font-size: clamp(10px, 1.5vw, 14px); /* Responsive font size for footer */
      color: rgba(224, 224, 224, 0.5); /* Adjusted for better visibility on dark bg */
      z-index: 100; /* High z-index to be on top of everything */
      pointer-events: none;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Ensure readable font */
    }

  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="wantedPosterContainer"></div>
    <canvas id="gameCanvas"></canvas>
    <div class="police-tape police-tape-top">POLICE LINE DO NOT CROSS --- POLICE LINE DO NOT CROSS</div>
    <div class="police-tape police-tape-bottom">POLICE LINE DO NOT CROSS --- POLICE LINE DO NOT CROSS</div>
    <div class="police-tape police-tape-left">POLICE LINE DO NOT CROSS</div>
    <div class="police-tape police-tape-right">POLICE LINE DO NOT CROSS</div>
  </div>

  <div class="footer-credit">Made by Taylan</div> <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let screenWidth, screenHeight;
    let gameRunning = false;
    let gamePaused = false;
    let animationFrameId;

    const MAX_PARTICLES = 200;
    const MAX_FEEDBACK_MESSAGES = 15;

    let audioContext;
    const sounds = {
        dispatchStart: null, backgroundMusic: null, radioStatic: null, siren: null,
        intercomMessages: [],
    };
    let backgroundMusicSource = null;

    async function loadSound(url) { /* ... (no changes from previous) ... */ }
    function playSound(buffer, loop = false, volume = 1) { /* ... (no changes) ... */ }

    const difficulties = { /* ... (no changes) ... */ };
    let currentDifficultySetting;
    let difficultySelection = ['Normal', 'Easy', 'Hard'];
    let selectedDifficultyIndex = 0;

    let currentBeatInterval, baseScannerSpeedMs, currentScannerSpeedMs, currentItemSpawnChance, currentItemActiveDurationMs;
    let lastBeatTime = 0, beatCount = 0;

    function applyDifficultySettings(difficultyNameOrObject) { /* ... (no changes from previous) ... */ }

    const SCANNER_COLOR_BASE = 'rgba(0, 255, 255, 0.7)';
    let scannerColor = SCANNER_COLOR_BASE;
    const SCANNER_WIDTH = 8;
    let scannerX = 0, scannerDirection = 1;
    const MAX_SCANNER_SPEED_INCREASE_FACTOR = 1.5;

    let items = [];
    const ITEM_RADIUS_BASE = 18;
    // ... (other item consts remain same)

    let score = 0, highScore = 0, lifetimeScore = 0, combo = 0;
    // ... (score consts remain same)

    let tapFeedback = [], particles = [];
    let lives = 3, INITIAL_LIVES = 3;
    // ... (stat counters remain same)
    let powerUpsStats = { focus: 0, freeze: 0, flashlight: 0 };


    let focusModeActive = false, focusModeEndTime = 0;
    // ... (power-up mode vars and consts remain same)
    let flashlightModeActive = false, flashlightModeEndTime = 0;

    const evidenceTypes = ['key', 'phone', 'footprint', 'document', 'sample', 'weapon_outline', 'datapad'];
    let backgroundHue = 200;

    let bossScanModeActive = false, bossScanTimer = 0, bossScanEndTime = 0;
    // ... (boss mode consts remain same)
    let difficultyBeforeBoss;

    const wantedPostersData = [ /* ... (no changes) ... */ ];
    let activeWantedPosters = [];

    let sirenFlashActive = false, sirenFlashEndTime = 0; // ... (siren consts remain same)

    const achievements = { /* ... (no changes) ... */ };
    const rankThresholds = [ /* ... (no changes) ... */ ];
    let currentRank; // Initialized in init

    let detectiveModeActive = false;
    const detectiveModeTapSequence = ['TOP_LEFT', 'BOTTOM_RIGHT', 'TOP_RIGHT', 'BOTTOM_LEFT'];
    let currentTapSequence = [];
    const DETECTIVE_MODE_TAP_AREA_SIZE_RATIO = 0.25;

    const intercomMessages = [ /* ... (paths should be valid, no code change here) ... */ ];
    let currentIntercomMessage = null, intercomMessageEndTime = 0, nextIntercomMessageTime = 0;

    function getItemFromStorage(key) { /* ... (no changes from previous) ... */ }
    function setItemInStorage(key, value) { /* ... (no changes from previous) ... */ }
    function getJsonFromStorage(key) { /* ... (no changes from previous) ... */ }
    function setJsonInStorage(key, value) { /* ... (no changes from previous) ... */ }

    function getRandom(min, max) { /* ... (no changes) ... */ }
    function getRandomInt(min, max) { /* ... (no changes) ... */ }

    function updateRankAndAchievements() { /* ... (no changes from previous) ... */ }

    function resizeCanvas() {
      screenWidth = window.innerWidth;
      screenHeight = window.innerHeight;
      
      const gameContainer = document.getElementById('gameContainer');
      gameContainer.style.width = `${screenWidth}px`;
      gameContainer.style.height = `${screenHeight}px`;

      // Canvas already set to 100% width/height of gameContainer in CSS
      // but setting width/height attributes resizes the drawing buffer
      canvas.width = screenWidth;
      canvas.height = screenHeight;
      scannerX = SCANNER_WIDTH / 2;

      const tapeElements = document.querySelectorAll('.police-tape');
      const tapeFontSize = Math.min(screenWidth * 0.015, screenHeight * 0.03, 18); // Slightly smaller max for tape
      tapeElements.forEach(tape => {
          tape.style.fontSize = `${tapeFontSize}px`;
          const tapeHeight = tapeFontSize * 2;
          tape.style.lineHeight = `${tapeHeight}px`;
          if (tape.classList.contains('police-tape-top') || tape.classList.contains('police-tape-bottom')) {
              tape.style.height = `${tapeHeight}px`;
          } else {
              tape.style.width = `${tapeHeight}px`;
          }
      });
      displayWantedPosters(false); 
      
      if (!gameRunning) {
          if (lives <= 0 && score > 0) drawEndGameReport();
          else drawStartScreen();
      } else {
          draw();
      }
    }
    
    function cycleDifficulty() { /* ... (no changes from previous) ... */ }
    function getTapZone(tapX, tapY) { /* ... (no changes from previous) ... */ }
    
    function handleTap(event) { /* ... (no changes from previous logic, audio loading moved to init more robustly) ... */ }

    function activateFocusMode(currentTime) { /* ... (no changes) ... */ }
    function deactivateFocusMode() { /* ... (no changes) ... */ }
    function activateFreezeMode(currentTime) { /* ... (no changes) ... */ }
    function deactivateFreezeMode() { /* ... (no changes) ... */ }
    function activateFlashlightMode(currentTime) { /* ... (no changes) ... */ }
    function deactivateFlashlightMode() { /* ... (no changes) ... */ }

    function addTapFeedback(x, y, text, color, time, isBonus = false) { /* ... (no changes from previous resource limit fix) ... */ }
    
    function spawnItem(currentTime) { /* ... (no changes from previous) ... */ }
    function updateItems(currentTime, deltaTime) { /* ... (no changes from previous) ... */ }
    function updateScanner(deltaTime) { /* ... (no changes from previous) ... */ }

    function createParticleExplosion(x,y,color,isError=false){ /* ... (no changes from previous resource limit fix) ... */ }
    function updateParticles(deltaTime){ /* ... (no changes) ... */ }
    function drawParticles(){ /* ... (no changes) ... */ }
    
    function drawIcon(type,x,y,radius,alpha,itemHidden = false){ /* ... (no changes from previous flashlight & roundRect fix) ... */ }

    function drawBackground(){ 
        backgroundHue=(backgroundHue+0.05)%360;
        let baseBgColor = `hsl(${backgroundHue},30%,5%)`;
        let midBgColor = `hsl(${backgroundHue},30%,10%)`;

        if (detectiveModeActive) {
            baseBgColor = `hsl(0,0%,10%)`; midBgColor = `hsl(0,0%,20%)`;
        }

        // document.body.style.backgroundColor is already set in CSS / can be dynamic if needed
        ctx.fillStyle = midBgColor;
        ctx.fillRect(0,0,screenWidth,screenHeight);
        
        ctx.save();
        if (detectiveModeActive) {
            ctx.filter = 'grayscale(100%) contrast(1.1)';
        } else {
            ctx.filter = 'none';
        }
        
        let overlayColor = null;
        // ... (overlay logic remains same) ...
        if (focusModeActive) overlayColor = 'rgba(100,0,100,0.15)';
        else if (freezeModeActive) overlayColor = 'rgba(0,100,100,0.25)';
        else if (flashlightModeActive) {
            const pulse = Math.sin(performance.now() / 300) * 0.05 + 0.05;
            overlayColor = `rgba(255, 255, 150, ${pulse})`;
        } else if (sirenFlashActive) {
            const flashCycle = Math.sin(performance.now() / 80);
            overlayColor = flashCycle > 0 ? 'rgba(255,0,0,0.3)' : 'rgba(0,0,255,0.3)';
        } else if (bossScanModeActive) {
            overlayColor = 'rgba(255,50,0,0.15)';
        }

        if(overlayColor) {
            ctx.fillStyle = overlayColor;
            ctx.fillRect(0,0,screenWidth,screenHeight);
        }
        // Filter remains active for subsequent canvas draws until ctx.restore()
    }

    function displayWantedPosters(randomize = true) {
        const container = document.getElementById('wantedPosterContainer');
        if (!container) return;

        if (randomize) {
            container.innerHTML = ''; 
            activeWantedPosters = [];
            const numPosters = getRandomInt(1,Math.min(3, wantedPostersData.length));
            for(let i=0; i < numPosters; i++) {
                let posterData; let attempts = 0;
                do {
                    posterData = wantedPostersData[getRandomInt(0, wantedPostersData.length - 1)];
                    attempts++;
                } while (activeWantedPosters.some(p => p.name === posterData.name) && attempts < wantedPostersData.length * 2)

                if (!activeWantedPosters.some(p => p.name === posterData.name)) {
                    const posterEl = document.createElement('div');
                    posterEl.classList.add('wanted-poster');
                    // Position posters more centrally, considering their size for edges
                    let posterWidthVW = parseFloat(getComputedStyle(posterEl).width) / screenWidth * 100 || 20; // estimate poster width as %
                    posterEl.style.left = `${getRandom(5, Math.max(10, 85 - posterWidthVW))}%`;
                    posterEl.style.top = `${getRandom(10, 70)}%`; // Keep from very top/bottom
                    // Wanted Poster Duplication Fix: Name now in H3
                    posterEl.innerHTML = `
                        <h3>WANTED: ${posterData.name}</h3>
                        <img src="${posterData.img}" alt="Wanted: ${posterData.name}" onerror="this.style.display='none'; this.parentElement.querySelector('h3').innerText='IMAGE CORRUPT';">
                        <p><small>${posterData.reason}</small></p>
                    `;
                    container.appendChild(posterEl);
                    activeWantedPosters.push(posterData);
                }
            }
        }
    }

    function drawScanner(){ 
      // ... (previous scanner drawing logic) ...
      let baseColor = SCANNER_COLOR_BASE;
      let glowWidthMultiplier = 2;

      if (bossScanModeActive) { /* ... */ }
      else if (combo >= HIGH_COMBO_THRESHOLD){ /* ... */ }
      if (focusModeActive) baseColor=`rgba(255,0,255,0.8)`;
      else if (freezeModeActive) baseColor=`rgba(150,200,255,0.8)`;
      
      ctx.fillStyle=baseColor;
      ctx.fillRect(scannerX-SCANNER_WIDTH/2,0,SCANNER_WIDTH,screenHeight);
      
      const timeSinceLastBeat=performance.now()-lastBeatTime;
      const pulseProgress=gamePaused?0:Math.min(1,timeSinceLastBeat/currentBeatInterval);
      
      // Scanner Flash Pulse Intensity Fix
      let baseSinPulse = Math.sin(pulseProgress*Math.PI); // Value from 0 to 1
      let clampedSinPulse = Math.max(0.05, baseSinPulse); // Ensures minimum visibility
      const pulseAlpha = clampedSinPulse * (focusModeActive?0.5:(freezeModeActive?0.4:0.3)); // Apply mode-specific factor

      let pulseColorRGB = '0,255,255';
      // ... (pulse color logic remains same) ...
      if (bossScanModeActive) pulseColorRGB = '255,100,0';
      else if (combo >= HIGH_COMBO_THRESHOLD) pulseColorRGB = '255,255,0';
      else if (focusModeActive) pulseColorRGB = '255,0,255';
      else if (freezeModeActive) pulseColorRGB = '150,200,255';

      ctx.fillStyle=`rgba(${pulseColorRGB}, ${pulseAlpha})`;
      ctx.fillRect(scannerX-SCANNER_WIDTH*glowWidthMultiplier,0,SCANNER_WIDTH*glowWidthMultiplier*2,screenHeight);
    }

    function drawItems(currentTime){ /* ... (no changes from previous) ... */ }
    
    function drawUI() {
      const xPadding = 40; // Scanner/Combo UI Clipping Fix
      ctx.fillStyle = detectiveModeActive ? '#A0A0A0' : '#E0E0E0';
      const fontSize = Math.max(18, screenWidth * 0.025);
      // Font family will use fallbacks since 'PoliceTech' is removed for now
      const gameFont = `'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
      ctx.font = `${fontSize}px ${gameFont}`;
      ctx.textAlign = 'left';
      
      ctx.fillText(`Units: ${lives}`, xPadding, fontSize*3);
      ctx.fillText(`Score: ${score}`, xPadding, fontSize*1.5);

      const comboBarWidth = screenWidth * 0.25;
      const comboBarHeight = fontSize * 0.8;
      const comboBarX = xPadding; // Align with padded text
      const comboBarY = fontSize * 4.2;
      // ... (combo bar logic remains same) ...
      ctx.strokeStyle = detectiveModeActive ? '#777' : '#E0E0E0'; ctx.lineWidth = 1;
      ctx.strokeRect(comboBarX, comboBarY, comboBarWidth, comboBarHeight);
      const comboProgress = Math.min(1, combo / MAX_COMBO_FOR_METER);
      ctx.fillStyle = combo >= HIGH_COMBO_THRESHOLD ? 'rgba(255,255,0,0.7)' : (bossScanModeActive ? 'rgba(255,100,0,0.7)' : SCANNER_COLOR_BASE);
      ctx.fillRect(comboBarX + 1, comboBarY + 1, comboProgress * (comboBarWidth-2), comboBarHeight-2);


      ctx.textAlign = 'right';
      ctx.fillStyle = detectiveModeActive ? '#A0A0A0' : '#E0E0E0';
      ctx.fillText(`Highest Score: ${highScore}`, screenWidth - xPadding, fontSize*1.5); // Add padding
      if (combo > 1) {
        const comboAlpha = Math.min(1, 0.3 + (combo * 0.07));
        ctx.fillStyle = bossScanModeActive ? `rgba(255,100,0, ${comboAlpha})` : `rgba(0, 255, 255, ${comboAlpha})`; 
        ctx.fillText(`Chain: x${combo}`, screenWidth - xPadding, fontSize*3); // Add padding
      }

      const rankBarY = fontSize * 5.7;
      const rankBarWidth = screenWidth * 0.25;
      ctx.textAlign = 'left'; // Switch back for rank label
      ctx.fillText(`Rank: ${currentRank.name}`, xPadding, rankBarY - fontSize * 0.3);
      // ... (rank bar logic remains same) ...
      ctx.strokeStyle = detectiveModeActive ? '#777' : '#E0E0E0';
      ctx.strokeRect(comboBarX, rankBarY, rankBarWidth, comboBarHeight * 0.8);
      const nextRankIndex = rankThresholds.findIndex(r => r.name === currentRank.name) + 1;
      let rankProgress = 0;
      if (nextRankIndex < rankThresholds.length) {
          const scoreInCurrentRank = lifetimeScore - currentRank.score;
          const scoreNeededForNextRank = rankThresholds[nextRankIndex].score - currentRank.score;
          rankProgress = scoreNeededForNextRank > 0 ? Math.min(1, scoreInCurrentRank / scoreNeededForNextRank) : 1;
      } else { rankProgress = 1; }
      ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
      ctx.fillRect(comboBarX + 1, rankBarY + 1, rankProgress * (rankBarWidth-2), (comboBarHeight*0.8)-2);

      // ... (power-up messages and intercom UI remain same) ...
      ctx.textAlign = 'center';
      if (focusModeActive) { /* ... */ } else if (freezeModeActive) { /* ... */ }
      else if (flashlightModeActive) { /* ... */ } else if (bossScanModeActive) { /* ... */ }
      if (currentIntercomMessage && performance.now() < intercomMessageEndTime) { /* ... */ }
    }

    function drawTapFeedback(currentTime){ /* ... (no changes from previous) ... */ }
    function drawStartScreen(){ /* ... (font family updated to fallback) ... */ }
    function drawEndGameReport(){ /* ... (font family updated to fallback) ... */ }

    let lastTime = 0;
    function gameLoop(currentTime) {
      if (!gameRunning && !freezeModeActive) { /* ... (no changes) ... */ }
      animationFrameId = requestAnimationFrame(gameLoop);

      const rawDeltaTime = currentTime - lastTime;
      // deltaTime Overflow Skipping Fix
      const deltaTime = gamePaused ? 0 : Math.min(rawDeltaTime, 100); // Use 0 if paused, else capped deltaTime
      lastTime = currentTime; // Always update lastTime to current real time

      // ... (power-up deactivation logic remains same) ...
      if (focusModeActive && currentTime >= focusModeEndTime) deactivateFocusMode();
      if (freezeModeActive && currentTime >= freezeModeEndTime) deactivateFreezeMode();
      if (flashlightModeActive && currentTime >= flashlightModeEndTime) deactivateFlashlightMode();
      if (sirenFlashActive && currentTime >= sirenFlashEndTime) sirenFlashActive = false;


      // ... (Boss Scan Logic, use 'deltaTime' which is now capped) ...
      if (!bossScanModeActive && gameRunning && !gamePaused) {
          bossScanTimer += deltaTime; // Use capped deltaTime for game timers
          // ... (rest of boss scan start logic)
      } else if (bossScanModeActive && currentTime >= bossScanEndTime) {
          // ... (boss scan end logic)
      }

      // ... (Police Intercom Logic, use 'deltaTime' for timing if needed, though current logic is fine) ...
      if (gameRunning && !gamePaused && currentTime >= nextIntercomMessageTime) { /* ... */ }
      if (currentTime > intercomMessageEndTime) currentIntercomMessage = null;

      if (!gamePaused) {
        if (currentTime - lastBeatTime >= currentBeatInterval) {
            lastBeatTime = currentTime - ((currentTime - lastBeatTime) % currentBeatInterval); // Sync beatTime
            beatCount++;
            if (gameRunning) spawnItem(currentTime);
        }
        updateScanner(deltaTime); // Use capped deltaTime
        updateItems(currentTime, deltaTime); // Pass both currentTime and capped deltaTime
      }
      updateParticles(deltaTime); // Use capped deltaTime
      draw();
    }

    function draw(){ /* ... (no changes from previous ctx.restore() fix) ... */ }
    function startGame() { /* ... (no changes from previous) ... */ }
    function gameOver() { /* ... (no changes from previous) ... */ }

    function init() {
      // UX Enhancements: Custom Cursor already handled by CSS for canvas, JS sets for non-touch
      if (!('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)) {
        canvas.style.cursor = "url('images/cursors/flashlight_cursor.cur'), auto";
      }
      // canvas.style.touchAction = 'none'; // Already in CSS
      // document.body.style.touchAction = 'none'; // Keep for global effect

      // Robust audio context initialization moved to first tap (handleTap)
      // but we can pre-load data paths for intercom here if not actual audio buffers
      // For now, intercomMessages array with paths is sufficient until first tap loads them.

      const storedAchievements = getJsonFromStorage('evidenceLockdownAchievementsV4Proto');
      if (storedAchievements) { /* ... */ }
      lifetimeScore = parseInt(getItemFromStorage('evidenceLockdownLifetimeScoreV4Proto') || "0");
      highScore = parseInt(getItemFromStorage('evidenceLockdownHighScoreV4Proto') || "0");
      
      // Initialize currentRank correctly before first drawStartScreen
      currentRank = rankThresholds[0]; // Default
      updateRankAndAchievements(); // Calculate initial rank based on loaded lifetimeScore

      applyDifficultySettings(difficultySelection[selectedDifficultyIndex]);

      resizeCanvas(); 
      window.addEventListener('resize', resizeCanvas);
      canvas.addEventListener('mousedown', handleTap);
      canvas.addEventListener('touchstart', handleTap, { passive: false });
      
      // Initial audio loading can start here if not dependent on user interaction for AudioContext
      // However, current setup defers to first tap for AudioContext creation.
      // This is generally safer across browsers.
      // If you pre-load paths, actual loading happens in handleTap.

      drawStartScreen(); 
    }

    // Initialize audio context and load essential sounds on first user interaction
    // This is mostly handled in handleTap now. If you need truly global sounds before any tap:
    // window.addEventListener('load', () => { /* init some non-gameplay sounds if desired */});

    init();
  </script>
</body>
</html>
