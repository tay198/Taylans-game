<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Evidence Lockdown: Sector Scan (V4.0 Proto) </title>
  <style>
    @font-face {
      font-family: 'PoliceTech'; /* Placeholder for a police-themed font */
      src: url('fonts/police-tech-font.woff2') format('woff2'), /* Example path */
           url('fonts/police-tech-font.woff') format('woff');   /* Example fallback */
      font-display: swap; /* Optimized loading */
    }

    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      color: #E0E0E0; /* Default text color */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'PoliceTech', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Apply new font */
      cursor: default;
      background-color: #000; /* Base background for body */
    }

    /* Stacking context wrapper */
    #gameContainer {
        position: relative;
        width: 100vw; /* Or match canvas logic */
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    canvas {
      display: block;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      position: relative; /* For z-indexing within gameContainer if needed */
      z-index: 5;     /* Canvas layer */
    }

    .police-tape {
      position: absolute;
      background-image: repeating-linear-gradient(
        45deg,
        #ffd700,
        #ffd700 20px,
        #333 20px,
        #333 40px
      );
      color: #000;
      font-weight: bold;
      text-align: center;
      font-size: 1.5vw;
      line-height: 3vw;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      z-index: 1; /* Behind game container elements if any, but on top of body bg */
                  /* If #gameContainer wraps these, they'd be relative to it. */
                  /* For simplicity, keeping them absolute to body, ensure #gameContainer is above if it has a background */
    }
    .police-tape-top, .police-tape-bottom {
        width: 100%;
        height: 3vw;
        left: 0;
    }
    .police-tape-left, .police-tape-right {
        height: 100%;
        width: 3vw;
        top: 0;
        writing-mode: vertical-rl;
        text-orientation: mixed;
    }
    .police-tape-top { top: 0; }
    .police-tape-bottom { bottom: 0; }
    .police-tape-left { left: 0; }
    .police-tape-right { right: 0; }

    #wantedPosterContainer {
        position: absolute;
        top: 0; /* Full screen, posters placed within */
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 4; /* Below canvas, above main background if canvas is transparent */
    }

    .wanted-poster {
        position: absolute;
        width: 10%;
        min-width: 80px;
        max-width: 150px;
        aspect-ratio: 0.7;
        background-color: #f0e6d2;
        border: 5px solid #5c3a21;
        box-shadow: 5px 5px 10px rgba(0,0,0,0.5);
        padding: 8px;
        text-align: center;
        font-family: 'Times New Roman', serif;
        color: #333;
        opacity: 0.7;
        /* z-index still relevant if multiple posters overlap, but poster container manages overall layer */
    }
    .wanted-poster h3 { margin: 0 0 5px 0; font-size: 1em; color: #000;}
    .wanted-poster img { width: 80%; margin-bottom: 5px; border: 1px solid #333;}
    .wanted-poster p { margin: 0; font-size: 0.7em;}

  </style>
</head>
<body>
  <div class="police-tape police-tape-top">POLICE LINE DO NOT CROSS --- POLICE LINE DO NOT CROSS</div>
  <div class="police-tape police-tape-bottom">POLICE LINE DO NOT CROSS --- POLICE LINE DO NOT CROSS</div>
  <div class="police-tape police-tape-left">POLICE LINE DO NOT CROSS</div>
  <div class="police-tape police-tape-right">POLICE LINE DO NOT CROSS</div>

  <div id="gameContainer">
    <div id="wantedPosterContainer"></div>
    <canvas id="gameCanvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let screenWidth, screenHeight;
    let gameRunning = false;
    let gamePaused = false;
    let animationFrameId;

    // --- Resource Limits ---
    const MAX_PARTICLES = 200;
    const MAX_FEEDBACK_MESSAGES = 15;

    // --- Audio Context and Elements ---
    let audioContext;
    const sounds = {
        dispatchStart: null,
        backgroundMusic: null,
        radioStatic: null,
        siren: null,
        intercomMessages: [], // Will be populated by loaded sounds
    };
    let backgroundMusicSource = null;

    async function loadSound(url) {
        if (!audioContext) return null;
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return await audioContext.decodeAudioData(arrayBuffer);
        } catch (error) {
            console.warn(`Error loading sound ${url}:`, error); // Use warn for non-critical asset errors
            return null;
        }
    }

    function playSound(buffer, loop = false, volume = 1) {
        if (!audioContext || !buffer) return null;
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const gainNode = audioContext.createGain();
        gainNode.gain.value = volume;
        source.connect(gainNode).connect(audioContext.destination);
        source.loop = loop;
        source.start();
        return source;
    }

    // --- Difficulty Settings & Sync ---
    const difficulties = {
        Easy:   { NAME: 'Easy',   BPM: 75, SCANNER_SPEED_MS: 0.10, SPAWN_CHANCE: 0.55, ITEM_DURATION_BEATS: 4.5, SCORE_SPEED_FACTOR: 0.000005 },
        Normal: { NAME: 'Normal', BPM: 90, SCANNER_SPEED_MS: 0.13, SPAWN_CHANCE: 0.65, ITEM_DURATION_BEATS: 4.0, SCORE_SPEED_FACTOR: 0.000007 },
        Hard:   { NAME: 'Hard',   BPM: 110,SCANNER_SPEED_MS: 0.16, SPAWN_CHANCE: 0.75, ITEM_DURATION_BEATS: 3.5, SCORE_SPEED_FACTOR: 0.00001 }
    };
    let currentDifficultySetting = difficulties.Normal; // Will be an object
    let difficultySelection = ['Normal', 'Easy', 'Hard']; // Keep for cycling
    let selectedDifficultyIndex = 0;

    let currentBeatInterval; // Set by applyDifficultySettings
    let lastBeatTime = 0;
    let beatCount = 0;

    let baseScannerSpeedMs; // Set by applyDifficultySettings
    let currentScannerSpeedMs;
    let currentItemSpawnChance; // Set by applyDifficultySettings
    let currentItemActiveDurationMs; // Set by applyDifficultySettings


    function applyDifficultySettings(difficultyNameOrObject) {
        let diffSetting;
        if (typeof difficultyNameOrObject === 'string') {
            diffSetting = difficulties[difficultyNameOrObject];
        } else {
            diffSetting = difficultyNameOrObject; // Assume it's a difficulty object
        }

        if (!diffSetting) {
            console.error("Invalid difficulty provided to applyDifficultySettings:", difficultyNameOrObject);
            diffSetting = difficulties.Normal; // Fallback
        }
        
        currentDifficultySetting = diffSetting; // Store the whole object

        baseScannerSpeedMs = diffSetting.SCANNER_SPEED_MS;
        currentScannerSpeedMs = baseScannerSpeedMs; // Initialize current speed
        currentBeatInterval = 60000 / diffSetting.BPM;
        currentItemSpawnChance = diffSetting.SPAWN_CHANCE;
        currentItemActiveDurationMs = currentBeatInterval * diffSetting.ITEM_DURATION_BEATS;
        console.log(`Difficulty applied: ${diffSetting.NAME}, BPM: ${diffSetting.BPM}`);
    }


    const SCANNER_COLOR_BASE = 'rgba(0, 255, 255, 0.7)';
    let scannerColor = SCANNER_COLOR_BASE;
    const SCANNER_WIDTH = 8;
    let scannerX = 0;
    let scannerDirection = 1;
    const MAX_SCANNER_SPEED_INCREASE_FACTOR = 1.5;

    let items = [];
    const ITEM_RADIUS_BASE = 18;
    const EVIDENCE_BASE_COLOR = 'rgba(0, 255, 0, 0.8)';
    const DISTRACTOR_COLOR = 'rgba(255, 165, 0, 0.8)';
    const POWERUP_COLOR = 'rgba(255, 0, 255, 0.9)';
    const POWERUP_FREEZE_COLOR = 'rgba(100, 150, 255, 0.9)';
    const POWERUP_FLASHLIGHT_COLOR = 'rgba(255, 255, 100, 0.9)';
    const FRAGMENT_COLOR = 'rgba(100, 200, 255, 0.8)';

    const DISTRACTOR_SPAWN_CHANCE = 0.25;
    const FRAGMENTED_EVIDENCE_SPAWN_CHANCE = 0.15;
    const POWERUP_SPAWN_CHANCE = 0.10;
    const POWERUP_TYPE_CHANCE = { focus: 0.4, freeze: 0.4, flashlight: 0.2 };

    let score = 0;
    let highScore = 0; // Loaded in init
    let lifetimeScore = 0; // Loaded in init
    let combo = 0;
    const SCORE_PER_EVIDENCE = 100;
    const SCORE_PER_FRAGMENT = 75;
    const FRAGMENT_SET_COMPLETION_BONUS = 150;
    const COMBO_MULTIPLIER_BONUS = 10;
    const MAX_COMBO_FOR_METER = 15;
    const HIGH_COMBO_THRESHOLD = 7;
    const PERFECT_COMBO_STREAK_FOR_SIREN = 15;

    const PENALTY_FOR_DISTRACTOR = -150;
    const PENALTY_FOR_MISS = -50;

    let tapFeedback = [];
    let particles = [];
    let lives = 3;
    const INITIAL_LIVES = 3;

    let evidenceCollectedCount = 0;
    let fragmentsCollectedCount = 0;
    let fragmentedSetsCompletedCount = 0;
    let distractorsHitCount = 0;
    let evidenceMissedCount = 0;
    let totalEvidenceOpportunities = 0;
    let powerUpsCollectedCount = 0;
    let powerUpsStats = { focus: 0, freeze: 0, flashlight: 0 };

    let focusModeActive = false; let focusModeEndTime = 0;
    const FOCUS_MODE_DURATION_MS = 7000; const FOCUS_MODE_SPEED_MULTIPLIER = 0.6;
    let freezeModeActive = false; let freezeModeEndTime = 0;
    const FREEZE_MODE_DURATION_MS = 3500;
    let flashlightModeActive = false; let flashlightModeEndTime = 0;
    const FLASHLIGHT_MODE_DURATION_MS = 5000;

    const evidenceTypes = ['key', 'phone', 'footprint', 'document', 'sample', 'weapon_outline', 'datapad'];
    let backgroundHue = 200;

    let bossScanModeActive = false;
    let bossScanTimer = 0;
    const BOSS_SCAN_INTERVAL = 60000;
    const BOSS_SCAN_DURATION = 15000;
    let bossScanEndTime = 0;
    let difficultyBeforeBoss; // To store the actual difficulty object

    const wantedPostersData = [
        { name: "Glitch Byte", reason: "Code Interference", img: "images/placeholders/wanted_glitch.png" },
        { name: "Silent Static", reason: "Signal Jamming", img: "images/placeholders/wanted_static.png" },
        { name: "Vector Vandall", reason: "Illegal Graphics", img: "images/placeholders/wanted_vector.png" }
    ];
    let activeWantedPosters = [];

    let sirenFlashActive = false;
    let sirenFlashEndTime = 0;
    const SIREN_FLASH_DURATION = 1000;

    const achievements = {
        rookie: { name: "Rookie Scanner", criteria: () => lifetimeScore >= 5000, unlocked: false, icon: "images/badges/badge_rookie.png"},
        veteran: { name: "Veteran Analyst", criteria: () => lifetimeScore >= 25000, unlocked: false, icon: "images/badges/badge_veteran.png"},
        master: { name: "Master Investigator", criteria: () => lifetimeScore >= 100000, unlocked: false, icon: "images/badges/badge_master.png"}
    };
    const rankThresholds = [
        { name: "Cadet", score: 0 }, { name: "Officer", score: 10000 }, { name: "Sergeant", score: 30000 },
        { name: "Lieutenant", score: 75000 }, { name: "Captain", score: 150000 }, { name: "Commander", score: 300000 }
    ];
    let currentRank = rankThresholds[0];

    let detectiveModeActive = false;
    // Tap sequence using defined zones from getTapZone
    const detectiveModeTapSequence = ['TOP_LEFT', 'BOTTOM_RIGHT', 'TOP_RIGHT', 'BOTTOM_LEFT'];
    let currentTapSequence = [];
    const DETECTIVE_MODE_TAP_AREA_SIZE_RATIO = 0.25; // 25% of screen width/height for corners

    const intercomMessages = [
        { text: "Scanner detected interference...", audio: "audio/intercom/interference.mp3" }, // Ensure these paths are valid
        { text: "Anomaly detected in Sector Gamma.", audio: "audio/intercom/anomaly_gamma.mp3" },
        { text: "Maintain scan integrity.", audio: "audio/intercom/maintain_integrity.mp3" },
        { text: "High priority target identified.", audio: "audio/intercom/high_priority.mp3" }
    ];
    let currentIntercomMessage = null;
    let intercomMessageEndTime = 0;
    let nextIntercomMessageTime = 0;

    function getItemFromStorage(key) {
        try {
            return localStorage.getItem(key);
        } catch (e) {
            console.warn("LocalStorage: Failed to get item", key, e);
            return null;
        }
    }

    function setItemInStorage(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            console.warn("LocalStorage: Failed to set item", key, e);
        }
    }
    
    function getJsonFromStorage(key) {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
        } catch (e) {
            console.warn("LocalStorage: Failed to get JSON item", key, e);
            return null;
        }
    }

    function setJsonInStorage(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
            console.warn("LocalStorage: Failed to set JSON item", key, e);
        }
    }


    function getRandom(min, max) { return Math.random() * (max - min) + min; }
    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function updateRankAndAchievements() {
        for (const achKey in achievements) {
            if (!achievements[achKey].unlocked && achievements[achKey].criteria()) {
                achievements[achKey].unlocked = true;
                addTapFeedback(screenWidth/2, screenHeight/2, `Badge Unlocked: ${achievements[achKey].name}!`, POWERUP_COLOR, performance.now(), true);
            }
        }
        setJsonInStorage('evidenceLockdownAchievementsV4Proto', achievements);

        let newRank = rankThresholds[0];
        for (let i = rankThresholds.length - 1; i >= 0; i--) {
            if (lifetimeScore >= rankThresholds[i].score) {
                newRank = rankThresholds[i];
                break;
            }
        }
        currentRank = newRank;
    }

    function resizeCanvas() {
      screenWidth = window.innerWidth;
      screenHeight = window.innerHeight;
      
      const gameContainer = document.getElementById('gameContainer');
      gameContainer.style.width = `${screenWidth}px`;
      gameContainer.style.height = `${screenHeight}px`;

      canvas.width = screenWidth;
      canvas.height = screenHeight;
      scannerX = SCANNER_WIDTH / 2;

      const tapeElements = document.querySelectorAll('.police-tape');
      const tapeFontSize = Math.min(screenWidth * 0.015, screenHeight * 0.03, 20); // Max 20px font for tape
      tapeElements.forEach(tape => {
          tape.style.fontSize = `${tapeFontSize}px`;
          const tapeHeight = tapeFontSize * 2;
          tape.style.lineHeight = `${tapeHeight}px`;
          if (tape.classList.contains('police-tape-top') || tape.classList.contains('police-tape-bottom')) {
              tape.style.height = `${tapeHeight}px`;
          } else {
              tape.style.width = `${tapeHeight}px`;
          }
      });
      displayWantedPosters(false); 
      
      // Performance Optimization Note:
      // If UI rendering during resize becomes an issue on some devices,
      // consider debouncing this call or using requestIdleCallback for drawStartScreen/drawEndGameReport.
      // For a running game, draw() is essential to reflect new dimensions immediately.
      if (!gameRunning) {
          if (lives <= 0 && score > 0) drawEndGameReport();
          else drawStartScreen();
      } else {
          // If game is running, the gameLoop will handle drawing.
          // A direct call to draw() here ensures immediate reflection of resize.
          draw();
      }
    }
    
    function cycleDifficulty() {
        selectedDifficultyIndex = (selectedDifficultyIndex + 1) % difficultySelection.length;
        applyDifficultySettings(difficultySelection[selectedDifficultyIndex]);
        if (!gameRunning) drawStartScreen();
    }

    function getTapZone(tapX, tapY) {
        const rect = canvas.getBoundingClientRect(); // Use this for accurate relative coordinates
        const x = tapX - rect.left;
        const y = tapY - rect.top;

        const cornerWidth = screenWidth * DETECTIVE_MODE_TAP_AREA_SIZE_RATIO;
        const cornerHeight = screenHeight * DETECTIVE_MODE_TAP_AREA_SIZE_RATIO;

        if (x < cornerWidth && y < cornerHeight) return 'TOP_LEFT';
        if (x > screenWidth - cornerWidth && y < cornerHeight) return 'TOP_RIGHT';
        if (x < cornerWidth && y > screenHeight - cornerHeight) return 'BOTTOM_LEFT';
        if (x > screenWidth - cornerWidth && y > screenHeight - cornerHeight) return 'BOTTOM_RIGHT';
        return null; // Not in a corner
    }
    
    function handleTap(event) {
      if (event) event.preventDefault();

      if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          Promise.all([
              loadSound("audio/placeholders/dispatch_start.mp3").then(b => sounds.dispatchStart = b),
              loadSound("audio/placeholders/scanner_music_90bpm.mp3").then(b => sounds.backgroundMusic = b),
              loadSound("audio/placeholders/radio_static_short.mp3").then(b => sounds.radioStatic = b),
              loadSound("audio/placeholders/siren_short.mp3").then(b => sounds.siren = b),
              Promise.all(intercomMessages.map(msg => loadSound(msg.audio))) // Load intercom sounds
                  .then(loadedIntercomAudio => {
                      // Assign loaded buffers back to the original structure or directly to sounds.intercomMessages
                      sounds.intercomMessages = loadedIntercomAudio.filter(b => b !== null); // Filter out nulls if loading failed for some
                      console.log("Intercom sounds loaded:", sounds.intercomMessages.length);
                  })
          ]).then(() => console.log("Audio assets potentially loaded."))
            .catch(err => console.error("Error loading initial audio assets:", err));
      }

      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;

      if (!gameRunning && !gamePaused) {
        const rect = canvas.getBoundingClientRect(); // For accurate tap relative to canvas
        const tapYInCanvas = clientY - rect.top;

        const difficultyTextYAreaStart = screenHeight * 0.68; 
        const difficultyTextYAreaEnd = screenHeight * 0.78;
        if (tapYInCanvas > difficultyTextYAreaStart && tapYInCanvas < difficultyTextYAreaEnd) {
             cycleDifficulty();
             return;
        }
        
        const tapZone = getTapZone(clientX, clientY); // Use clientX/Y for zone detection
        if (tapZone) {
            currentTapSequence.push(tapZone);
            if (currentTapSequence.length > detectiveModeTapSequence.length) currentTapSequence.shift();
            if (JSON.stringify(currentTapSequence) === JSON.stringify(detectiveModeTapSequence)) {
                detectiveModeActive = !detectiveModeActive;
                currentTapSequence = [];
                addTapFeedback(screenWidth/2, screenHeight/2, `Detective Mode: ${detectiveModeActive ? 'ON' : 'OFF'}`, POWERUP_COLOR, performance.now());
                drawStartScreen();
                return;
            }
        } else if (currentTapSequence.length > 0 && !detectiveModeTapSequence.includes(tapZone)) { // Reset if tap is not part of sequence and sequence started
            currentTapSequence = [];
        }

        startGame();
        return;
      }
      if (gamePaused && !freezeModeActive) return;

      const tapTime = performance.now();
      let itemHitProcessed = false;

      for (let i = items.length - 1; i >= 0; i--) {
        if (itemHitProcessed) break;
        const item = items[i];
        
        // Skip if item is hidden and flashlight not active
        if (item.hidden && !flashlightModeActive) continue;

        if (Math.abs(item.x - scannerX) < item.radius + SCANNER_WIDTH + 10 &&
            tapTime >= item.spawnTime && tapTime <= item.spawnTime + currentItemActiveDurationMs) {
            if (scannerX >= item.x - item.radius && scannerX <= item.x + item.radius) {
                itemHitProcessed = true;
                let pointsEarnedThisTap = 0;
                let hitColor = item.color || EVIDENCE_BASE_COLOR;

                if (item.type === 'evidence') {
                    pointsEarnedThisTap = SCORE_PER_EVIDENCE + (combo * COMBO_MULTIPLIER_BONUS);
                    score += pointsEarnedThisTap; combo++; evidenceCollectedCount++;
                    createParticleExplosion(item.x, item.y, EVIDENCE_BASE_COLOR);
                } else if (item.type === 'fragment') {
                    pointsEarnedThisTap = SCORE_PER_FRAGMENT;
                    score += pointsEarnedThisTap; fragmentsCollectedCount++;
                    hitColor = FRAGMENT_COLOR;
                    createParticleExplosion(item.x, item.y, FRAGMENT_COLOR);
                    const parent = items.find(p => p.id === item.parentId && p.type === 'fragment_parent');
                    if (parent) {
                        parent.fragmentsCollected++;
                        if (parent.fragmentsCollected >= parent.totalFragments) {
                            let bonusPoints = FRAGMENT_SET_COMPLETION_BONUS;
                            score += bonusPoints; pointsEarnedThisTap += bonusPoints; 
                            fragmentedSetsCompletedCount++;
                            addTapFeedback(parent.x, parent.y, `Set! +${bonusPoints}`, EVIDENCE_BASE_COLOR, tapTime, true);
                            items = items.filter(it => it.id !== parent.id && it.parentId !== parent.id);
                        }
                    }
                } else if (item.type === 'powerup_focus') {
                    activateFocusMode(tapTime); powerUpsCollectedCount++; powerUpsStats.focus++; pointsEarnedThisTap = 0;
                    hitColor = POWERUP_COLOR; createParticleExplosion(item.x, item.y, POWERUP_COLOR);
                } else if (item.type === 'powerup_freeze') {
                    activateFreezeMode(tapTime); powerUpsCollectedCount++; powerUpsStats.freeze++; pointsEarnedThisTap = 0;
                    hitColor = POWERUP_FREEZE_COLOR; createParticleExplosion(item.x, item.y, POWERUP_FREEZE_COLOR);
                } else if (item.type === 'powerup_flashlight') {
                    activateFlashlightMode(tapTime); powerUpsCollectedCount++; powerUpsStats.flashlight++; pointsEarnedThisTap = 0;
                    hitColor = POWERUP_FLASHLIGHT_COLOR; createParticleExplosion(item.x, item.y, POWERUP_FLASHLIGHT_COLOR);
                } else if (item.type === 'distractor') {
                    score = Math.max(0, score + PENALTY_FOR_DISTRACTOR); combo = 0; lives--;
                    distractorsHitCount++; pointsEarnedThisTap = PENALTY_FOR_DISTRACTOR;
                    hitColor = DISTRACTOR_COLOR; createParticleExplosion(item.x, item.y, DISTRACTOR_COLOR, true);
                    playSound(sounds.radioStatic, false, 0.5);
                }
                addTapFeedback(item.x, item.y, (pointsEarnedThisTap >= 0 ? `+${pointsEarnedThisTap}`: `${pointsEarnedThisTap}`), hitColor, tapTime);
                items.splice(i, 1);

                if (combo > 0 && combo % PERFECT_COMBO_STREAK_FOR_SIREN === 0) {
                    playSound(sounds.siren, false, 0.7);
                    sirenFlashActive = true;
                    sirenFlashEndTime = performance.now() + SIREN_FLASH_DURATION;
                }
                break;
            }
        }
      }
      if (lives <= 0) gameOver();
    }

    function activateFocusMode(currentTime) { focusModeActive = true; freezeModeActive = false; flashlightModeActive = false; focusModeEndTime = currentTime + FOCUS_MODE_DURATION_MS;}
    function deactivateFocusMode() { focusModeActive = false; }
    function activateFreezeMode(currentTime) { freezeModeActive = true; focusModeActive = false; flashlightModeActive = false; freezeModeEndTime = currentTime + FREEZE_MODE_DURATION_MS; gamePaused = true;}
    function deactivateFreezeMode() { freezeModeActive = false; gamePaused = false; lastBeatTime = performance.now(); lastTime = performance.now(); }
    function activateFlashlightMode(currentTime) {
        flashlightModeActive = true; focusModeActive = false; freezeModeActive = false;
        flashlightModeEndTime = currentTime + FLASHLIGHT_MODE_DURATION_MS;
    }
    function deactivateFlashlightMode() { flashlightModeActive = false; }

    function addTapFeedback(x, y, text, color, time, isBonus = false) {
        if (tapFeedback.length >= MAX_FEEDBACK_MESSAGES) {
            tapFeedback.shift(); // Remove the oldest if cap is reached
        }
        tapFeedback.push({ x, y, text, color, spawnTime: time, alpha: 1, scale: isBonus ? 1.3 : 1 });
    }
    
    let itemIdCounter = 0;
    function spawnItem(currentTime) { 
        let effectiveSpawnChance = currentItemSpawnChance; // From applyDifficultySettings
        if (bossScanModeActive) effectiveSpawnChance *= 1.5;

        if (Math.random() > effectiveSpawnChance) return;
        const spawnRoll = Math.random();
        let itemTypeToSpawn, itemIconType;
        let initiallyHidden = false;

        if (spawnRoll < POWERUP_SPAWN_CHANCE) {
            const powerupRoll = Math.random();
            if (powerupRoll < POWERUP_TYPE_CHANCE.focus) itemTypeToSpawn = 'powerup_focus';
            else if (powerupRoll < POWERUP_TYPE_CHANCE.focus + POWERUP_TYPE_CHANCE.freeze) itemTypeToSpawn = 'powerup_freeze';
            else itemTypeToSpawn = 'powerup_flashlight';
            
            if (itemTypeToSpawn === 'powerup_focus') itemIconType = 'powerup_focus_icon';
            else if (itemTypeToSpawn === 'powerup_freeze') itemIconType = 'powerup_freeze_icon';
            else itemIconType = 'powerup_flashlight_icon';

        } else if (spawnRoll < POWERUP_SPAWN_CHANCE + FRAGMENTED_EVIDENCE_SPAWN_CHANCE) {
            itemTypeToSpawn = 'fragment_parent';
        } else {
            itemTypeToSpawn = Math.random() < DISTRACTOR_SPAWN_CHANCE ? 'distractor' : 'evidence';
            if(itemTypeToSpawn === 'evidence') {
                itemIconType = evidenceTypes[getRandomInt(0, evidenceTypes.length - 1)];
                if (Math.random() < 0.15) { // 15% chance for regular evidence to be initially hidden
                    initiallyHidden = true;
                }
            } else {
                 itemIconType = 'distractor_icon';
            }
        }
        
        const x = getRandom(ITEM_RADIUS_BASE * 2.5, screenWidth - ITEM_RADIUS_BASE * 2.5);
        const y = getRandom(ITEM_RADIUS_BASE * 2.5, screenHeight - ITEM_RADIUS_BASE * 2.5);
        for (const existingItem of items) {
            if (Math.hypot(existingItem.x - x, existingItem.y - y) < ITEM_RADIUS_BASE * 5) return; 
        }
        itemIdCounter++;

        if (itemTypeToSpawn === 'fragment_parent') {
            totalEvidenceOpportunities++; 
            const numFragments = getRandomInt(2, 3);
            items.push({ id: itemIdCounter, type: 'fragment_parent', x, y, totalFragments: numFragments, fragmentsCollected: 0, spawnTime: currentTime, alpha: 0, radius: ITEM_RADIUS_BASE * 0.5 });
            const parentId = itemIdCounter;
            for (let i = 0; i < numFragments; i++) {
                itemIdCounter++;
                const angle = (i / numFragments) * Math.PI * 2 + getRandom(-0.2, 0.2);
                items.push({ id: itemIdCounter, parentId: parentId, type: 'fragment', x: x + Math.cos(angle) * ITEM_RADIUS_BASE * 2.5, y: y + Math.sin(angle) * ITEM_RADIUS_BASE * 2, radius: ITEM_RADIUS_BASE * 0.8, color: FRAGMENT_COLOR, iconType: evidenceTypes[getRandomInt(0, evidenceTypes.length-1)], spawnTime: currentTime + i * (currentBeatInterval / (numFragments * 1.5)), alpha: 0, hidden: initiallyHidden }); // Fragments can also be hidden
            }
        } else {
            if(itemTypeToSpawn === 'evidence') totalEvidenceOpportunities++;
            let color;
            if (itemTypeToSpawn === 'evidence') color = EVIDENCE_BASE_COLOR;
            else if (itemTypeToSpawn === 'powerup_focus') color = POWERUP_COLOR;
            else if (itemTypeToSpawn === 'powerup_freeze') color = POWERUP_FREEZE_COLOR;
            else if (itemTypeToSpawn === 'powerup_flashlight') color = POWERUP_FLASHLIGHT_COLOR;
            else color = DISTRACTOR_COLOR;
            items.push({ id: itemIdCounter, x, y, radius: ITEM_RADIUS_BASE, type: itemTypeToSpawn, color: color, iconType: itemIconType, spawnTime: currentTime, alpha: 0, hidden: initiallyHidden });
        }
    }

    function updateItems(currentTime, deltaTime) {
      if (gamePaused && !freezeModeActive) return;
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (item.alpha < 1 && currentTime >= item.spawnTime) {
          item.alpha += (deltaTime / (currentBeatInterval / 2.5)); 
          item.alpha = Math.min(1, item.alpha);
        }
        
        const itemLifetime = currentItemActiveDurationMs + (item.type === 'fragment' ? currentBeatInterval : 0);
        if (item.type !== 'fragment_parent' && currentTime > item.spawnTime + itemLifetime) {
          if ((item.type === 'evidence' || item.type === 'fragment') && !(item.hidden && !flashlightModeActive) ) { // Only penalize if it was visible or became visible
            score = Math.max(0, score + PENALTY_FOR_MISS); combo = 0; evidenceMissedCount++;
            addTapFeedback(item.x, item.y, 'Missed!', DISTRACTOR_COLOR, currentTime);
            playSound(sounds.radioStatic, false, 0.3);
          }
          items.splice(i, 1);
        }
      }
      if (lives <= 0 && gameRunning) gameOver();
    }

    function updateScanner(deltaTime) {
      if (gamePaused) return;
      let scoreFactor = score * currentDifficultySetting.SCORE_SPEED_FACTOR;
      let dynamicSpeedMs = baseScannerSpeedMs * (1 + Math.min(scoreFactor, MAX_SCANNER_SPEED_INCREASE_FACTOR -1));
      
      if (bossScanModeActive) dynamicSpeedMs = difficulties.Hard.SCANNER_SPEED_MS * 1.2; // Use a more defined boss speed or scale current
      
      currentScannerSpeedMs = focusModeActive ? dynamicSpeedMs * FOCUS_MODE_SPEED_MULTIPLIER : dynamicSpeedMs;
      
      scannerX += currentScannerSpeedMs * deltaTime * scannerDirection;

      if (scannerX + SCANNER_WIDTH / 2 >= screenWidth) {
        scannerX = screenWidth - SCANNER_WIDTH / 2; 
        scannerDirection = -1;
      } else if (scannerX - SCANNER_WIDTH / 2 <= 0) {
        scannerX = SCANNER_WIDTH / 2; 
        scannerDirection = 1;
      }
    }

    function createParticleExplosion(x,y,color,isError=false){
        const count=isError?15:25;
        const s=isError?2:3;
        for(let i=0;i<count;i++){
            if (particles.length >= MAX_PARTICLES) {
                particles.shift(); // Remove oldest particle
            }
            particles.push({x,y,vx:getRandom(-s,s),vy:getRandom(-s,s),radius:getRandom(isError?3:2,isError?5:4),color:color.replace(/, [0-9\.]+\)/,`, ${getRandom(0.5,1)})`),lifespan:getRandom(300,600),spawnTime:performance.now(),alpha:1});
        }
    }
    function updateParticles(deltaTime){ for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx*(deltaTime/16);p.y+=p.vy*(deltaTime/16);p.alpha=Math.max(0,1-(performance.now()-p.spawnTime)/p.lifespan);p.vy+=0.05;if(p.alpha<=0)particles.splice(i,1);}}
    function drawParticles(){ particles.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.radius*p.alpha,0,Math.PI*2);ctx.fillStyle=p.color.replace(/, [0-9\.]+\)/,`, ${p.alpha*0.8})`);ctx.fill();});}
    
    function drawIcon(type,x,y,radius,alpha,itemHidden = false){
      // Flashlight Mode Inconsistency Fix:
      if (itemHidden && !flashlightModeActive) {
          // Option 1: Suppress draw call entirely
          // return; 
          // Option 2: Render very translucent/obfuscated (almost invisible)
          alpha *= 0.05; // Make it extremely faint, almost invisible
          if (alpha < 0.01) return; // If too faint, don't bother drawing
      }

      ctx.save();
      ctx.translate(x,y);
      
      let displayAlpha = alpha;
      if (itemHidden && flashlightModeActive) { // Pulsate when revealed by flashlight
          displayAlpha = alpha * (0.8 + Math.sin(performance.now()/150)*0.2); // Ensure it's clearly visible
          ctx.shadowBlur = 15;
          ctx.shadowColor = POWERUP_FLASHLIGHT_COLOR.replace(/, [0-9\.]+\)/,`, ${Math.min(displayAlpha, 0.7)})`); // Cap shadow alpha
      }

      ctx.globalAlpha = displayAlpha;
      const iC=EVIDENCE_BASE_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha})`);
      ctx.lineWidth=2; ctx.strokeStyle=iC; ctx.fillStyle=iC;

      switch(type){
        case 'key':ctx.beginPath();ctx.arc(0,-radius*0.4,radius*0.3,0,Math.PI*2);ctx.moveTo(0,-radius*0.1);ctx.lineTo(0,radius*0.6);ctx.lineTo(radius*0.2,radius*0.6);ctx.moveTo(0,radius*0.3);ctx.lineTo(radius*0.2,radius*0.3);ctx.stroke();break;
        case 'phone':ctx.strokeRect(-radius*0.5,-radius*0.7,radius,radius*1.4);ctx.fillRect(-radius*0.3,-radius*0.55,radius*0.6,radius*0.15);ctx.beginPath();ctx.arc(0,radius*0.4,radius*0.1,0,Math.PI*2);ctx.fill();break;
        case 'footprint':ctx.beginPath();ctx.ellipse(0,0,radius*0.5,radius*0.8,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(0,-radius*0.6,radius*0.4,radius*0.3,Math.PI*0.1,0,Math.PI*2);ctx.fill();break;
        case 'document':ctx.strokeRect(-radius*0.6,-radius*0.7,radius*1.2,radius*1.4);for(let i=0;i<3;i++){ctx.beginPath();ctx.moveTo(-radius*0.45,-radius*0.4+i*radius*0.3);ctx.lineTo(radius*0.45,-radius*0.4+i*radius*0.3);ctx.stroke();}break;
        case 'sample':ctx.beginPath();ctx.moveTo(-radius*0.3,-radius*0.6);ctx.lineTo(-radius*0.3,radius*0.4);ctx.quadraticCurveTo(-radius*0.3,radius*0.7,0,radius*0.7);ctx.quadraticCurveTo(radius*0.3,radius*0.7,radius*0.3,radius*0.4);ctx.lineTo(radius*0.3,-radius*0.6);ctx.closePath();ctx.stroke();ctx.fillRect(-radius*0.2,-radius*0.1,radius*0.4,radius*0.5);break;
        case 'weapon_outline': 
            ctx.beginPath(); ctx.moveTo(-radius * 0.7, radius * 0.3); ctx.lineTo(-radius * 0.3, radius * 0.3);
            ctx.lineTo(-radius * 0.2, -radius * 0.5); ctx.lineTo(radius * 0.2, -radius * 0.5);
            ctx.lineTo(radius * 0.3, radius * 0.3); ctx.lineTo(radius * 0.7, radius * 0.3);
            ctx.lineTo(radius * 0.6, radius * 0.5); ctx.lineTo(-radius * 0.6, radius * 0.5);
            ctx.closePath(); ctx.stroke(); break;
        case 'datapad': // ctx.roundRect fallback
            ctx.beginPath();
            const r = radius * 0.1; // Corner radius
            const x_ = -radius * 0.6, y_ = -radius * 0.8;
            const w_ = radius * 1.2, h_ = radius * 1.6;
            if (ctx.roundRect) { // Check if roundRect is supported
                ctx.roundRect(x_, y_, w_, h_, r);
            } else { // Manual fallback for rounded rectangle
                ctx.moveTo(x_ + r, y_);
                ctx.lineTo(x_ + w_ - r, y_); ctx.quadraticCurveTo(x_ + w_, y_, x_ + w_, y_ + r);
                ctx.lineTo(x_ + w_, y_ + h_ - r); ctx.quadraticCurveTo(x_ + w_, y_ + h_, x_ + w_ - r, y_ + h_);
                ctx.lineTo(x_ + r, y_ + h_); ctx.quadraticCurveTo(x_, y_ + h_, x_, y_ + h_ - r);
                ctx.lineTo(x_, y_ + r); ctx.quadraticCurveTo(x_, y_, x_ + r, y_);
            }
            ctx.closePath();
            ctx.stroke(); ctx.fillStyle = EVIDENCE_BASE_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.2})`); ctx.fill(); // Semi-transparent fill
            break;
        case 'powerup_focus_icon':ctx.strokeStyle=POWERUP_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha})`);ctx.fillStyle=POWERUP_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.5})`);ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,0,radius*0.5,0,Math.PI*2);ctx.lineWidth=1.5;ctx.stroke();break;
        case 'powerup_freeze_icon':ctx.strokeStyle=POWERUP_FREEZE_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha})`);ctx.fillStyle=POWERUP_FREEZE_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.5})`);ctx.beginPath();for(let i=0;i<6;i++){ctx.moveTo(0,0);ctx.lineTo(Math.cos(i*Math.PI/3)*radius,Math.sin(i*Math.PI/3)*radius);ctx.moveTo(Math.cos(i*Math.PI/3+Math.PI/6)*radius*0.5,Math.sin(i*Math.PI/3+Math.PI/6)*radius*0.5);ctx.lineTo(Math.cos(i*Math.PI/3-Math.PI/6)*radius*0.5,Math.sin(i*Math.PI/3-Math.PI/6)*radius*0.5);}ctx.stroke();break;
        case 'powerup_flashlight_icon':
            ctx.strokeStyle = POWERUP_FLASHLIGHT_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha})`);
            ctx.fillStyle = POWERUP_FLASHLIGHT_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.5})`);
            ctx.beginPath(); ctx.arc(0,0,radius,0,Math.PI*2); ctx.fill();ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -radius*0.3); ctx.lineTo(-radius*0.5, radius*0.6);
            ctx.lineTo(radius*0.5, radius*0.6); ctx.closePath();
            ctx.fillStyle = POWERUP_FLASHLIGHT_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.8})`);
            ctx.fill(); break;
        case 'distractor_icon':ctx.fillStyle=DISTRACTOR_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.8})`);ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle='rgba(50,0,0,'+displayAlpha+')';ctx.lineWidth=3;ctx.moveTo(-radius*0.5,-radius*0.5);ctx.lineTo(radius*0.5,radius*0.5);ctx.moveTo(radius*0.5,-radius*0.5);ctx.lineTo(-radius*0.5,radius*0.5);ctx.stroke();break;
        default:if(type==='fragment'){ctx.fillStyle=FRAGMENT_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha*0.7})`);ctx.strokeStyle=FRAGMENT_COLOR.replace(/, [0-9\.]+\)/,`, ${displayAlpha})`);}ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2);ctx.fill();if(type==='fragment')ctx.stroke();break;
      }
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawBackground(){ 
        backgroundHue=(backgroundHue+0.05)%360;
        let baseBgColor = `hsl(${backgroundHue},30%,5%)`;
        let midBgColor = `hsl(${backgroundHue},30%,10%)`;

        if (detectiveModeActive) {
            baseBgColor = `hsl(0,0%,10%)`; midBgColor = `hsl(0,0%,20%)`;
            // Apply filter directly to canvas context for game elements
            // Note: This might affect performance. Consider applying to specific drawing functions.
        }

        document.body.style.backgroundColor = baseBgColor; // This is outside canvas, won't be affected by ctx.filter
        ctx.fillStyle = midBgColor;
        ctx.fillRect(0,0,screenWidth,screenHeight);
        
        // Save context before applying filters that might affect subsequent non-game-element draws in this function
        ctx.save();
        if (detectiveModeActive) {
            ctx.filter = 'grayscale(100%) contrast(1.1)';
        } else {
            ctx.filter = 'none'; // Ensure reset if not in detective mode
        }
        
        let overlayColor = null;
        if (focusModeActive) overlayColor = 'rgba(100,0,100,0.15)';
        else if (freezeModeActive) overlayColor = 'rgba(0,100,100,0.25)';
        else if (flashlightModeActive) {
            const pulse = Math.sin(performance.now() / 300) * 0.05 + 0.05;
            overlayColor = `rgba(255, 255, 150, ${pulse})`;
        } else if (sirenFlashActive) {
            const flashCycle = Math.sin(performance.now() / 80);
            overlayColor = flashCycle > 0 ? 'rgba(255,0,0,0.3)' : 'rgba(0,0,255,0.3)';
        } else if (bossScanModeActive) {
            overlayColor = 'rgba(255,50,0,0.15)';
        }

        if(overlayColor) {
            ctx.fillStyle = overlayColor;
            ctx.fillRect(0,0,screenWidth,screenHeight);
        }
        // The detective mode filter is applied here. It will affect everything drawn to the canvas
        // after this point in the `draw` function until ctx.restore() or filter is changed.
    }

    function displayWantedPosters(randomize = true) {
        const container = document.getElementById('wantedPosterContainer');
        if (!container) return;

        if (randomize) {
            container.innerHTML = ''; 
            activeWantedPosters = [];
            const numPosters = getRandomInt(1,Math.min(3, wantedPostersData.length)); // Ensure not more than available
            for(let i=0; i < numPosters; i++) {
                let posterData;
                let attempts = 0;
                // Ensure unique posters if possible
                do {
                    posterData = wantedPostersData[getRandomInt(0, wantedPostersData.length - 1)];
                    attempts++;
                } while (activeWantedPosters.some(p => p.name === posterData.name) && attempts < wantedPostersData.length * 2)

                if (!activeWantedPosters.some(p => p.name === posterData.name)) { // Final check
                    const posterEl = document.createElement('div');
                    posterEl.classList.add('wanted-poster');
                    posterEl.style.left = `${getRandom(5, Math.max(10, 75 - parseFloat(posterEl.style.width || 10)))}%`; // Adjust to prevent going off-screen
                    posterEl.style.top = `${getRandom(5, Math.max(10, 75 - parseFloat(posterEl.style.height || 15)))}%`; // Adjust for height
                    posterEl.innerHTML = `
                        <h3>WANTED</h3>
                        <img src="${posterData.img}" alt="${posterData.name}" onerror="this.style.display='none'">
                        <p><strong>${posterData.name}</strong></p>
                        <p><small>${posterData.reason}</small></p>
                    `;
                    container.appendChild(posterEl);
                    activeWantedPosters.push(posterData);
                }
            }
        }
    }

    function drawScanner(){ 
      let baseColor = SCANNER_COLOR_BASE;
      let glowWidthMultiplier = 2;

      if (bossScanModeActive) {
          baseColor = 'rgba(255, 100, 0, 0.8)'; glowWidthMultiplier = 4;
      } else if (combo >= HIGH_COMBO_THRESHOLD){
          baseColor =`rgba(255,255,0,0.8)`; glowWidthMultiplier=3.5;
      }
      
      if (focusModeActive) baseColor=`rgba(255,0,255,0.8)`;
      else if (freezeModeActive) baseColor=`rgba(150,200,255,0.8)`;
      
      ctx.fillStyle=baseColor;
      ctx.fillRect(scannerX-SCANNER_WIDTH/2,0,SCANNER_WIDTH,screenHeight);
      
      const timeSinceLastBeat=performance.now()-lastBeatTime;
      const pulseProgress=gamePaused?0:Math.min(1,timeSinceLastBeat/currentBeatInterval);
      const pulseAlpha=Math.sin(pulseProgress*Math.PI)*(focusModeActive?0.5:0.3);
      
      let pulseColorRGB = '0,255,255';
      if (bossScanModeActive) pulseColorRGB = '255,100,0';
      else if (combo >= HIGH_COMBO_THRESHOLD) pulseColorRGB = '255,255,0';
      else if (focusModeActive) pulseColorRGB = '255,0,255';
      else if (freezeModeActive) pulseColorRGB = '150,200,255';

      ctx.fillStyle=`rgba(${pulseColorRGB}, ${pulseAlpha})`;
      ctx.fillRect(scannerX-SCANNER_WIDTH*glowWidthMultiplier,0,SCANNER_WIDTH*glowWidthMultiplier*2,screenHeight);
    }

    function drawItems(currentTime){ 
        items.forEach(item=>{
            if(item.type==='fragment_parent')return;
            
            // If item is hidden and flashlight not active, it will be handled by drawIcon directly
            // by either not drawing or drawing very faintly. No need for an explicit 'continue' here
            // if drawIcon returns early or draws faintly enough.

            const timeToExpire=(item.spawnTime+currentItemActiveDurationMs)-currentTime;
            let scaleFactor=1;
            if(timeToExpire<currentItemActiveDurationMs&&timeToExpire>0){
                scaleFactor=Math.max(0.3,timeToExpire/currentItemActiveDurationMs);
            } else if(timeToExpire<=0){
                scaleFactor=0.3;
            }
            const pulse=gamePaused?0.85:Math.sin((currentTime-item.spawnTime)/(currentBeatInterval/2.5)*Math.PI)*0.15+0.85;
            const currentRadius=item.radius*pulse*item.alpha*scaleFactor;
            
            // Let drawIcon handle visibility of hidden items based on flashlightModeActive
            if(item.iconType) drawIcon(item.iconType,item.x,item.y,currentRadius,item.alpha, item.hidden);
            else drawIcon(item.type,item.x,item.y,currentRadius,item.alpha, item.hidden);
      });
    }
    
    function drawUI() {
      ctx.fillStyle = detectiveModeActive ? '#A0A0A0' : '#E0E0E0';
      const fontSize = Math.max(18, screenWidth * 0.025);
      const policeFont = `'PoliceTech', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
      ctx.font = `${fontSize}px ${policeFont}`;
      ctx.textAlign = 'left';
      
      ctx.fillText(`Units: ${lives}`, 20, fontSize*3);
      ctx.fillText(`Score: ${score}`, 20, fontSize*1.5);

      const comboBarWidth = screenWidth * 0.25;
      const comboBarHeight = fontSize * 0.8;
      const comboBarX = 20;
      const comboBarY = fontSize * 4.2;
      ctx.strokeStyle = detectiveModeActive ? '#777' : '#E0E0E0'; ctx.lineWidth = 1;
      ctx.strokeRect(comboBarX, comboBarY, comboBarWidth, comboBarHeight);
      const comboProgress = Math.min(1, combo / MAX_COMBO_FOR_METER);
      ctx.fillStyle = combo >= HIGH_COMBO_THRESHOLD ? 'rgba(255,255,0,0.7)' : (bossScanModeActive ? 'rgba(255,100,0,0.7)' : SCANNER_COLOR_BASE);
      ctx.fillRect(comboBarX + 1, comboBarY + 1, comboProgress * (comboBarWidth-2), comboBarHeight-2);

      ctx.textAlign = 'right';
      ctx.fillStyle = detectiveModeActive ? '#A0A0A0' : '#E0E0E0';
      ctx.fillText(`Highest Score: ${highScore}`, screenWidth-20, fontSize*1.5);
      if (combo > 1) {
        const comboAlpha = Math.min(1, 0.3 + (combo * 0.07));
        ctx.fillStyle = bossScanModeActive ? `rgba(255,100,0, ${comboAlpha})` : `rgba(0, 255, 255, ${comboAlpha})`; 
        ctx.fillText(`Chain: x${combo}`, screenWidth-20, fontSize*3);
      }

      const rankBarY = fontSize * 5.7;
      const rankBarWidth = screenWidth * 0.25;
      ctx.textAlign = 'left';
      ctx.fillText(`Rank: ${currentRank.name}`, 20, rankBarY - fontSize * 0.3);
      ctx.strokeStyle = detectiveModeActive ? '#777' : '#E0E0E0';
      ctx.strokeRect(comboBarX, rankBarY, rankBarWidth, comboBarHeight * 0.8);
      const nextRankIndex = rankThresholds.findIndex(r => r.name === currentRank.name) + 1;
      let rankProgress = 0;
      if (nextRankIndex < rankThresholds.length) {
          const scoreInCurrentRank = lifetimeScore - currentRank.score;
          const scoreNeededForNextRank = rankThresholds[nextRankIndex].score - currentRank.score;
          rankProgress = scoreNeededForNextRank > 0 ? Math.min(1, scoreInCurrentRank / scoreNeededForNextRank) : 1;
      } else {
          rankProgress = 1;
      }
      ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
      ctx.fillRect(comboBarX + 1, rankBarY + 1, rankProgress * (rankBarWidth-2), (comboBarHeight*0.8)-2);

      ctx.textAlign = 'center';
      if (focusModeActive) { 
          ctx.fillStyle = POWERUP_COLOR; ctx.font = `bold ${fontSize}px ${policeFont}`;
          ctx.fillText(`SCAN FOCUS ACTIVE!`, screenWidth/2, screenHeight - fontSize * 2.5);
          const timeLeft = Math.max(0, (focusModeEndTime - performance.now()) / 1000).toFixed(1);
          ctx.font = `${fontSize*0.8}px ${policeFont}`; ctx.fillText(`${timeLeft}s`, screenWidth/2, screenHeight - fontSize * 1.5);
      } else if (freezeModeActive) {
          ctx.fillStyle = POWERUP_FREEZE_COLOR; ctx.font = `bold ${fontSize}px ${policeFont}`;
          ctx.fillText(`SYSTEM FROZEN!`, screenWidth/2, screenHeight - fontSize * 2.5);
          const timeLeft = Math.max(0, (freezeModeEndTime - performance.now()) / 1000).toFixed(1);
          ctx.font = `${fontSize*0.8}px ${policeFont}`; ctx.fillText(`${timeLeft}s`, screenWidth/2, screenHeight - fontSize * 1.5);
      } else if (flashlightModeActive) {
          ctx.fillStyle = POWERUP_FLASHLIGHT_COLOR; ctx.font = `bold ${fontSize}px ${policeFont}`;
          ctx.fillText(`FLASHLIGHT SCAN!`, screenWidth/2, screenHeight - fontSize * 2.5);
          const timeLeft = Math.max(0, (flashlightModeEndTime - performance.now()) / 1000).toFixed(1);
          ctx.font = `${fontSize*0.8}px ${policeFont}`; ctx.fillText(`${timeLeft}s`, screenWidth/2, screenHeight - fontSize * 1.5);
      } else if (bossScanModeActive) {
          ctx.fillStyle = 'rgba(255,50,0,0.9)'; ctx.font = `bold ${fontSize*1.2}px ${policeFont}`;
          ctx.fillText(`!!! BOSS SCAN PROTOCOL !!!`, screenWidth/2, screenHeight - fontSize * 2.5);
          const timeLeft = Math.max(0, (bossScanEndTime - performance.now()) / 1000).toFixed(1);
          ctx.font = `${fontSize*0.9}px ${policeFont}`; ctx.fillText(`Remaining: ${timeLeft}s`, screenWidth/2, screenHeight - fontSize * 1.5);
      }

      if (currentIntercomMessage && performance.now() < intercomMessageEndTime) {
          ctx.font = `${fontSize*0.9}px ${policeFont}`;
          ctx.fillStyle = 'rgba(255, 255, 180, 0.9)';
          ctx.textAlign = 'center';
          ctx.fillText(currentIntercomMessage.text, screenWidth/2, fontSize*1.5);
      }
    }

    function drawTapFeedback(currentTime){ for(let i=tapFeedback.length-1;i>=0;i--){const fb=tapFeedback[i];const age=currentTime-fb.spawnTime;const fadeDuration=900;if(age>fadeDuration){tapFeedback.splice(i,1);continue;}fb.alpha=1-(age/fadeDuration);const yPos=fb.y-(age/12);const currentScale=fb.scale*(1+(age/fadeDuration)*0.3);ctx.save();ctx.translate(fb.x,yPos);ctx.scale(currentScale,currentScale);ctx.font=`bold ${Math.max(18,screenWidth*0.022)}px ${detectiveModeActive ? 'Courier New' : 'Arial'}`;ctx.fillStyle=fb.color.replace(/, [0-9\.]+\)/,`, ${fb.alpha})`);ctx.textAlign='center';ctx.fillText(fb.text,0,0);ctx.restore();}}
    
    function drawStartScreen(){ 
        drawBackground(); 
        ctx.restore(); // Restore from drawBackground's potential filter
        ctx.filter = 'none'; // Explicitly ensure no filter for start screen UI

        ctx.fillStyle= detectiveModeActive ? '#A0A0A0' : '#E0E0E0';
        ctx.textAlign='center';
        const titleFontSize=Math.max(32,screenWidth*0.06);
        const mainMessageFontSize=Math.max(22,screenWidth*0.04);
        const subFontSize=Math.max(18,screenWidth*0.035);
        const difficultyFontSize=Math.max(18,screenWidth*0.03);
        const attributionFontSize = Math.max(12, screenWidth * 0.02);
        const policeFont = `'PoliceTech', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;

        let yPos=screenHeight*0.22;
        ctx.font=`bold ${titleFontSize}px ${policeFont}`; ctx.fillText("Evidence Lockdown: Sector Scan",screenWidth/2,yPos); yPos+=titleFontSize*1.3;
        ctx.font=`${mainMessageFontSize}px ${policeFont}`; ctx.fillText("Tap Screen to Initialize Scan Protocol",screenWidth/2,yPos); yPos+=mainMessageFontSize*1.5;
        ctx.font=`${subFontSize}px ${policeFont}`; ctx.fillText(`Highest Score: ${highScore}`,screenWidth/2,yPos); yPos+=subFontSize*1.3;
        ctx.fillText(`Rank: ${currentRank.name}`, screenWidth/2, yPos); yPos+=subFontSize*2.2;
        ctx.font=`bold ${difficultyFontSize}px ${policeFont}`; ctx.fillText(`Threat Level: ${currentDifficultySetting.NAME}`,screenWidth/2,yPos); yPos+=difficultyFontSize*1.0;
        ctx.font=`${difficultyFontSize*0.8}px ${policeFont}`; ctx.fillText("(Tap to Adjust Protocol)",screenWidth/2,yPos);

        yPos += difficultyFontSize * 2.5;
        ctx.font = `${attributionFontSize*1.1}px ${policeFont}`; ctx.fillText("Service Medals:", screenWidth/2, yPos); yPos += attributionFontSize * 1.5;
        let badgeX = screenWidth/2 - (Object.values(achievements).filter(a=>a.unlocked).length * (attributionFontSize*2.5))/2;
        Object.values(achievements).forEach(ach => {
            if (ach.unlocked) {
                ctx.fillStyle = 'gold';
                ctx.beginPath(); ctx.arc(badgeX + attributionFontSize, yPos + attributionFontSize, attributionFontSize*0.8, 0, Math.PI*2); ctx.fill();
                badgeX += attributionFontSize * 2.5;
            }
        });

        yPos = screenHeight * 0.92; 
        ctx.font = `${attributionFontSize}px ${policeFont}`;
        ctx.fillStyle = detectiveModeActive ? 'rgba(120,120,120,0.6)' : 'rgba(224, 224, 224, 0.6)';
        ctx.fillText("System Design: Taylan | Unit Ver. 4.0.1 Proto", screenWidth/2, yPos); // Version bump

        if (detectiveModeActive) {
            ctx.fillStyle = 'rgba(150,200,255,0.7)';
            ctx.font = `italic ${attributionFontSize*0.9}px ${policeFont}`;
            ctx.fillText("Detective Mode Engaged", screenWidth/2, screenHeight*0.05);
        }
    }
    
    function drawEndGameReport(){ 
        drawBackground(); 
        ctx.restore(); // Restore from drawBackground's potential filter
        ctx.filter = 'none'; // Explicitly ensure no filter for end game report UI

        ctx.fillStyle= detectiveModeActive ? 'rgba(30,30,30,0.9)' : 'rgba(10,10,10,0.9)';
        ctx.fillRect(0,0,screenWidth,screenHeight);
        ctx.fillStyle= detectiveModeActive ? '#A0A0A0' : '#E0E0E0';
        ctx.textAlign='center';
        const policeFont = `'PoliceTech', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
        const titleFS=Math.max(30,screenWidth*0.06);
        let yPos=screenHeight*0.10;
        
        ctx.font=`bold ${titleFS}px ${policeFont}`; ctx.fillText("INCIDENT REPORT CLOSED",screenWidth/2,yPos); yPos+=titleFS*1.3;
        const headerFS=Math.max(20,screenWidth*0.035);
        ctx.font=`bold ${headerFS}px ${policeFont}`; ctx.fillText(`FINAL ASSESSMENT: ${score}`,screenWidth/2,yPos); yPos+=headerFS*1.1;
        const detailFS=Math.max(16,screenWidth*0.028);
        ctx.font=`${detailFS}px ${policeFont}`;
        const prevHighScore = parseInt(getItemFromStorage('evidenceLockdownHighScoreV4Proto') || "0"); // Get it before updating highScore potentially
        if(score === highScore && score > 0 && score > prevHighScore) { // Check if it's a new high score compared to what was loaded
             ctx.fillText(`NEW RECORD ESTABLISHED! PREVIOUS: ${prevHighScore}`, screenWidth/2,yPos);
        } else {
            ctx.fillText(`Session High Score: ${highScore}`,screenWidth/2,yPos); // Show current session's high score
        }
        yPos+=detailFS*1.3;
        
        let accuracy=0;
        const successfulScans=evidenceCollectedCount+fragmentedSetsCompletedCount;
        const totalPossibleScans=totalEvidenceOpportunities;
        if(totalPossibleScans>0){accuracy=(successfulScans/totalPossibleScans)*100;}
        
        ctx.font=`bold ${Math.max(18,screenWidth*0.030)}px ${policeFont}`; ctx.fillText(`Operational Efficiency: ${accuracy.toFixed(1)}%`,screenWidth/2,yPos); yPos+=Math.max(18,screenWidth*0.030)*1.3;
        ctx.textAlign='left';
        const col1X=screenWidth*0.1; const col2X=screenWidth*0.55;
        const statFS=Math.max(15,screenWidth*0.026);
        ctx.font=`${statFS}px ${policeFont}`;
        let rightColY=yPos;
        
        ctx.fillText(`Evidence Logged: ${evidenceCollectedCount}`,col1X,yPos); yPos+=statFS*1.3;
        ctx.fillText(`Fragment Sets Secured: ${fragmentedSetsCompletedCount}`,col1X,yPos); yPos+=statFS*1.3;
        ctx.fillText(`Items Missed: ${evidenceMissedCount}`,col1X,yPos); yPos+=statFS*1.3;
        ctx.fillText(`Contaminations Hit: ${distractorsHitCount}`,col1X,yPos); yPos+=statFS*1.3;
        
        ctx.fillText(`Focus Power-ups: ${powerUpsStats.focus}`,col2X,rightColY); rightColY+=statFS*1.3;
        ctx.fillText(`Freeze Power-ups: ${powerUpsStats.freeze}`,col2X,rightColY); rightColY+=statFS*1.3;
        ctx.fillText(`Flashlight Power-ups: ${powerUpsStats.flashlight}`,col2X,rightColY); rightColY+=statFS*1.3;
        ctx.fillText(`Total Lifetime Score: ${lifetimeScore}`, col2X, rightColY); rightColY+=statFS*1.3;

        yPos = Math.max(yPos, rightColY) + statFS * 2.0;
        ctx.textAlign='center';
        ctx.font=`${Math.max(18,screenWidth*0.032)}px ${policeFont}`;
        ctx.fillText("Tap Screen to Debrief and Restart",screenWidth/2,screenHeight*0.9);
    }

    let lastTime = 0;
    function gameLoop(currentTime) {
      if (!gameRunning && !freezeModeActive) { // Ensure game over report or start screen is shown if not running
        if (lives <= 0 && score > 0) { if(animationFrameId) cancelAnimationFrame(animationFrameId); drawEndGameReport(); return;}
        else if (!gameRunning && items.length === 0 && (lives > 0 || score === 0) ) { if(animationFrameId) cancelAnimationFrame(animationFrameId); drawStartScreen(); return;}
        // If here, it implies game was stopped by some other means, ensure loop doesn't continue if not needed.
        return;
      }
      animationFrameId = requestAnimationFrame(gameLoop);

      const deltaTime = currentTime - lastTime;
      if(deltaTime > 100 && !freezeModeActive) { 
          lastTime = currentTime; return; 
      }
      lastTime = currentTime;

      if (focusModeActive && currentTime >= focusModeEndTime) deactivateFocusMode();
      if (freezeModeActive && currentTime >= freezeModeEndTime) deactivateFreezeMode();
      if (flashlightModeActive && currentTime >= flashlightModeEndTime) deactivateFlashlightMode();
      if (sirenFlashActive && currentTime >= sirenFlashEndTime) sirenFlashActive = false;

      if (!bossScanModeActive && gameRunning && !gamePaused) {
          bossScanTimer += deltaTime;
          if (bossScanTimer >= BOSS_SCAN_INTERVAL) {
              bossScanModeActive = true;
              bossScanEndTime = currentTime + BOSS_SCAN_DURATION;
              bossScanTimer = 0;
              difficultyBeforeBoss = { ...currentDifficultySetting }; // Store copy of current settings object

              // Apply a more distinct boss difficulty, e.g., Hard difficulty with modifications
              let bossDiff = { ...difficulties.Hard }; // Start with Hard settings
              bossDiff.SCANNER_SPEED_MS *= 1.3; // Make it even faster than standard hard
              bossDiff.SPAWN_CHANCE = Math.min(1, difficulties.Hard.SPAWN_CHANCE * 1.3);
              bossDiff.ITEM_DURATION_BEATS *= 0.7;
              bossDiff.NAME = "BOSS SCAN"; // Give it a name for clarity if needed
              // Don't call applyDifficultySettings for boss mode directly, as it changes baseScannerSpeedMs
              // Instead, modify current... variables directly or use a temp override system
              currentScannerSpeedMs = bossDiff.SCANNER_SPEED_MS; // Directly override
              currentItemSpawnChance = bossDiff.SPAWN_CHANCE;
              currentBeatInterval = 60000 / bossDiff.BPM; // If boss has different BPM
              currentItemActiveDurationMs = currentBeatInterval * bossDiff.ITEM_DURATION_BEATS;

              addTapFeedback(screenWidth/2, screenHeight*0.3, "!!! BOSS SCAN INITIATED !!!", 'rgba(255,0,0,0.9)', currentTime, true);
          }
      } else if (bossScanModeActive && currentTime >= bossScanEndTime) {
          bossScanModeActive = false;
          applyDifficultySettings(difficultyBeforeBoss); // Revert to settings before boss mode
          addTapFeedback(screenWidth/2, screenHeight*0.3, "Boss Scan Complete. Systems Normalizing.", 'rgba(0,255,0,0.9)', currentTime, true);
      }

      if (gameRunning && !gamePaused && currentTime >= nextIntercomMessageTime) {
          if (Math.random() < 0.001 && sounds.intercomMessages.length > 0) { 
              const messageIndex = getRandomInt(0, sounds.intercomMessages.length - 1);
              if (sounds.intercomMessages[messageIndex]) { // Check if buffer is loaded
                currentIntercomMessage = intercomMessages[messageIndex]; // Use original text object
                playSound(sounds.intercomMessages[messageIndex], false, 0.6);
                intercomMessageEndTime = currentTime + 5000;
              }
              nextIntercomMessageTime = currentTime + getRandom(20000, 40000);
          } else if (sounds.intercomMessages.length === 0) { // If no sounds loaded, still advance timer
              nextIntercomMessageTime = currentTime + getRandom(20000, 40000);
          }
      }
      if (currentTime > intercomMessageEndTime) currentIntercomMessage = null;

      if (!gamePaused) {
        if (currentTime - lastBeatTime >= currentBeatInterval) {
            lastBeatTime = currentTime - ((currentTime - lastBeatTime) % currentBeatInterval);
            beatCount++;
            if (gameRunning) spawnItem(currentTime);
        }
        updateScanner(deltaTime);
        updateItems(currentTime, deltaTime);
      }
      updateParticles(deltaTime);
      draw();
    }

    function draw(){ 
      ctx.clearRect(0,0,screenWidth,screenHeight);
      drawBackground(); // This now saves and applies/resets ctx.filter
      // Items drawn after background will inherit the filter if active (e.g., detective mode)
      drawScanner();
      drawItems(performance.now());
      // UI should ideally be drawn after restoring the context if it shouldn't be filtered
      ctx.restore(); // Restore from drawBackground's save (which applied filter)
      ctx.filter = 'none'; // Ensure UI is not filtered by detective mode's canvas filter

      drawUI(); 
      drawParticles(); // Particles might look better if also affected by filter, or drawn before restore.
      drawTapFeedback(performance.now());
    }

    function startGame() {
      if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

      playSound(sounds.dispatchStart, false, 0.8);
      if (backgroundMusicSource && typeof backgroundMusicSource.stop === 'function') {
          try { backgroundMusicSource.stop(); } catch(e) { console.warn("Failed to stop previous music source", e); }
      }
      backgroundMusicSource = playSound(sounds.backgroundMusic, true, 0.3);

      applyDifficultySettings(difficultySelection[selectedDifficultyIndex]); // Apply selected difficulty

      score = 0; combo = 0; lives = INITIAL_LIVES;
      items = []; tapFeedback = []; particles = []; beatCount = 0; itemIdCounter = 0;
      evidenceCollectedCount = 0; fragmentsCollectedCount = 0; fragmentedSetsCompletedCount = 0;
      distractorsHitCount = 0; evidenceMissedCount = 0; powerUpsCollectedCount = 0; totalEvidenceOpportunities = 0;
      powerUpsStats = { focus: 0, freeze: 0, flashlight: 0 };

      deactivateFocusMode(); deactivateFreezeMode(); deactivateFlashlightMode();
      gamePaused = false;
      scannerX = SCANNER_WIDTH / 2; scannerDirection = 1;
      lastBeatTime = performance.now(); lastTime = performance.now();
      
      bossScanModeActive = false; bossScanTimer = 0; sirenFlashActive = false;
      nextIntercomMessageTime = performance.now() + getRandom(5000, 10000);
      displayWantedPosters(true);
      gameRunning = true;
      gameLoop(performance.now());
    }

    function gameOver() {
      gameRunning = false; gamePaused = false;
      if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
      if (backgroundMusicSource && typeof backgroundMusicSource.stop === 'function') {
          try { backgroundMusicSource.stop(); } catch(e) { console.warn("Failed to stop music source on game over", e); }
          backgroundMusicSource = null;
      }
      
      lifetimeScore += score;
      setItemInStorage('evidenceLockdownLifetimeScoreV4Proto', lifetimeScore.toString());

      const storedHighScore = parseInt(getItemFromStorage('evidenceLockdownHighScoreV4Proto') || "0");
      if (score > storedHighScore ) {
          setItemInStorage('evidenceLockdownHighScoreV4Proto', score.toString());
          highScore = score; 
      } else {
          highScore = storedHighScore; // Ensure highScore reflects the stored one if not beaten
      }
      updateRankAndAchievements();
      drawEndGameReport();
    }

    function init() {
      if (!('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)) {
        canvas.style.cursor = "url('images/cursors/flashlight_cursor.cur'), auto";
        // Add .png fallback suggestion: "url('images/cursors/flashlight.png') 16 16, auto";
      }

      canvas.style.touchAction = 'none'; document.body.style.touchAction = 'none';

      const storedAchievements = getJsonFromStorage('evidenceLockdownAchievementsV4Proto');
      if (storedAchievements) {
        for (const key in achievements) {
            if (storedAchievements[key] !== undefined) { // Check if key exists in stored data
                achievements[key].unlocked = storedAchievements[key].unlocked;
            }
        }
      }
      lifetimeScore = parseInt(getItemFromStorage('evidenceLockdownLifetimeScoreV4Proto') || "0");
      highScore = parseInt(getItemFromStorage('evidenceLockdownHighScoreV4Proto') || "0");
      applyDifficultySettings(difficultySelection[selectedDifficultyIndex]); // Initial difficulty application

      updateRankAndAchievements();
      resizeCanvas(); 
      window.addEventListener('resize', resizeCanvas);
      canvas.addEventListener('mousedown', handleTap);
      canvas.addEventListener('touchstart', handleTap, { passive: false });
      
      drawStartScreen(); 
    }

    init();
  </script>
</body>
</html>
