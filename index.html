<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>AI ChatBot by Taylan - Advanced</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" data-manual></script>
    <style>
        :root {
            --body-bg-light: #f4f6f8; --body-bg-dark: #0d1117;
            --chat-bg-light: #ffffff; --chat-bg-dark: #161b22;
            --header-bg-light: #007bff; --header-bg-dark: #1f6feb;
            --header-text-light: #ffffff; --header-text-dark: #c9d1d9;
            --user-msg-bg-light: #007bff; --user-msg-bg-dark: #1f6feb;
            --user-msg-text-light: #ffffff; --user-msg-text-dark: #e0e0e0;
            --bot-msg-bg-light: #e9ecef; --bot-msg-bg-dark: #21262d;
            --bot-msg-text-light: #333333; --bot-msg-text-dark: #c9d1d9;
            --input-bg-light: #ffffff; --input-bg-dark: #0d1117;
            --input-text-light: #333333; --input-text-dark: #c9d1d9;
            --input-border-light: #ced4da; --input-border-dark: #30363d;
            --button-bg-light: #007bff; --button-bg-dark: #238636;
            --button-text-light: #ffffff; --button-text-dark: #ffffff;
            --text-color-light: #212529; --text-color-dark: #c9d1d9;
            --border-color-light: #dee2e6; --border-color-dark: #30363d;
            --shadow-light: 0 2px 10px rgba(0,0,0,0.075); --shadow-dark: 0 3px 12px rgba(0,0,0,0.25);
            --focus-ring-light: rgba(0,123,255,0.25); --focus-ring-dark: rgba(31,111,235,0.4);
            --suggestion-bg-light: #e0e0e0; --suggestion-bg-dark: #2a2a2a;
            --suggestion-text-light: #333; --suggestion-text-dark: #ccc;
            --body-bg: var(--body-bg-light); --chat-bg: var(--chat-bg-light);
            --header-bg: var(--header-bg-light); --header-text: var(--header-text-light);
            --user-msg-bg: var(--user-msg-bg-light); --user-msg-text: var(--user-msg-text-light);
            --bot-msg-bg: var(--bot-msg-bg-light); --bot-msg-text: var(--bot-msg-text-light);
            --input-bg: var(--input-bg-light); --input-text: var(--input-text-light);
            --input-border: var(--input-border-light); --button-bg: var(--button-bg-light);
            --button-text: var(--button-text-light); --text-color: var(--text-color-light);
            --border-color: var(--border-color-light); --shadow: var(--shadow-light);
            --focus-ring: var(--focus-ring-light);
            --suggestion-bg: var(--suggestion-bg-light); --suggestion-text: var(--suggestion-text-light);
        }
        body.dark-mode {
            --body-bg: var(--body-bg-dark); --chat-bg: var(--chat-bg-dark);
            --header-bg: var(--header-bg-dark); --header-text: var(--header-text-dark);
            --user-msg-bg: var(--user-msg-bg-dark); --user-msg-text: var(--user-msg-text-dark);
            --bot-msg-bg: var(--bot-msg-bg-dark); --bot-msg-text: var(--bot-msg-text-dark);
            --input-bg: var(--input-bg-dark); --input-text: var(--input-text-dark);
            --input-border: var(--input-border-dark); --button-bg: var(--button-bg-dark);
            --button-text: var(--button-text-dark); --text-color: var(--text-color-dark);
            --border-color: var(--border-color-dark); --shadow: var(--shadow-dark);
            --focus-ring: var(--focus-ring-dark);
            --suggestion-bg: var(--suggestion-bg-dark); --suggestion-text: var(--suggestion-text-dark);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        html { height: 100%; }
        body {
            background-color: var(--body-bg); color: var(--text-color);
            display: flex; flex-direction: row; 
            min-height: 100%; transition: background-color 0.3s, color 0.3s;
        }

        .threads-sidebar {
            width: 250px;
            background-color: var(--chat-bg);
            border-right: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, border-color 0.3s;
            display: none; 
        }
        .threads-sidebar h3 { margin-bottom: 10px; font-size: 1.1em; color: var(--text-color); }
        .threads-sidebar ul { list-style: none; }
        .threads-sidebar li button { 
            width: 100%; text-align: left; padding: 8px; margin-bottom: 5px;
            background: none; border: 1px solid transparent; color: var(--text-color);
            border-radius: 5px; cursor: pointer;
        }
        .threads-sidebar li button:hover, .threads-sidebar li button.active {
            background-color: var(--bot-msg-bg); border-color: var(--button-bg);
        }
        #newThreadButton { margin-top: auto; padding: 10px; }

        .chat-area { 
            flex-grow: 1; 
            display: flex; flex-direction: column;
            height: 100vh; 
            height: 100dvh; 
        }

        .chat-container { 
            width: 100%;
            max-width: 100%; 
            flex-grow: 1; 
            background-color: var(--chat-bg);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s;
        }
        .chat-container.flash { animation: subtleBackgroundFlash 0.5s ease-out forwards; }
        @keyframes subtleBackgroundFlash {
            0% { background-color: var(--chat-bg); }
            25% { background-color: color-mix(in srgb, var(--chat-bg) 95%, var(--button-bg) 5%); }
            100% { background-color: var(--chat-bg); }
        }

        .chat-header {
            padding: 10px 15px; background-color: var(--header-bg); color: var(--header-text);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color); transition: all 0.3s; flex-shrink: 0;
        }
        .chat-header h2 { font-size: 1.1em; margin: 0; display: flex; flex-direction: column; align-items: flex-start; }
        .chat-header h2 .title-main { line-height: 1; }
        .chat-header h2 .title-subtitle { font-size: 0.65em; font-weight: normal; opacity: 0.85; margin-top: 2px; line-height: 1; }
        
        .header-controls { display: flex; align-items: center; gap: 10px; }
        .header-controls label { font-size: 0.8em; }
        .header-controls select, .header-controls button {
            padding: 5px 8px; border-radius: 5px; border: 1px solid var(--header-text);
            background-color: var(--header-bg); color: var(--header-text); font-size: 0.8em;
        }
        .header-controls button:hover { background-color: var(--header-text); color: var(--header-bg); }

        .chat-window {
            flex-grow: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px;
            scrollbar-width: thin; scrollbar-color: var(--button-bg) var(--chat-bg);
        }
        .chat-window::-webkit-scrollbar { width: 8px; }
        .chat-window::-webkit-scrollbar-track { background: var(--chat-bg); }
        .chat-window::-webkit-scrollbar-thumb { background-color: var(--button-bg); border-radius: 10px; border: 2px solid var(--chat-bg); }

        .message {
            padding: 10px 15px; border-radius: 18px; max-width: 80%; line-height: 1.5;
            opacity: 0; transform: translateY(10px); animation: fadeInMessage 0.4s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
            word-wrap: break-word; position: relative; 
        }
        @keyframes fadeInMessage { 0% { opacity: 0; transform: translateY(15px) scale(0.95); } 100% { opacity: 1; transform: translateY(0) scale(1); } }
        .message.fade-out { animation: fadeOutMessage 0.3s ease forwards; }
        @keyframes fadeOutMessage { to { opacity: 0; transform: translateY(-5px); height: 0; padding:0; margin:0; border:0; } }

        .message.user { background-color: var(--user-msg-bg); color: var(--user-msg-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .message.bot { background-color: var(--bot-msg-bg); color: var(--bot-msg-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        
        .message-actions { 
            position: absolute; bottom: -5px; right: -5px; display: none; gap: 3px;
            background-color: var(--chat-bg); padding:3px; border-radius: 5px; box-shadow: var(--shadow);
        }
        .message:hover .message-actions { display: flex; }
        .message-actions button { background: none; border: none; cursor: pointer; font-size: 0.9em; padding: 3px; }
        .message-actions button:hover { opacity: 0.7; }

        /* Typing indicator / Loading spinner */
        .message.bot.typing, .message.bot.loading { 
            display: flex; align-items: center;
            background-color: var(--bot-msg-bg);
            color: var(--bot-msg-text);
            padding: 10px 15px;
            border-radius: 18px;
            border-bottom-left-radius: 5px;
            align-self: flex-start;
        }
        .message.bot.typing .dot { display:inline-block; width:9px; height:9px; border-radius:50%; background:currentColor; animation:bounceTyping 1.3s infinite ease-in-out; margin:0 2.5px; }
        .message.bot.typing .dot:nth-child(1){animation-delay:0s;} .message.bot.typing .dot:nth-child(2){animation-delay:.15s;} .message.bot.typing .dot:nth-child(3){animation-delay:.3s;}
        @keyframes bounceTyping { 0%,70%,100%{transform:translateY(0) scale(.6);opacity:.6} 35%{transform:translateY(-4px) scale(1);opacity:1} }

        .loading-spinner {
            width: 20px; height: 20px;
            border: 3px solid currentColor;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }


        .suggestions-container, .commands-suggestion-container {
            padding: 5px 15px 10px; display: flex; flex-wrap: wrap; gap: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .suggestions-container button, .commands-suggestion-container button {
            padding: 6px 10px; border-radius: 15px; border: 1px solid var(--input-border);
            background-color: var(--suggestion-bg); color: var(--suggestion-text);
            font-size: 0.85em; cursor: pointer; transition: background-color 0.2s;
        }
        .suggestions-container button:hover, .commands-suggestion-container button:hover { opacity: 0.8; }
        .commands-suggestion-container { border-top: 1px solid var(--border-color); border-bottom: none; padding-top:10px; }


        .chat-input-form {
            display: flex; padding: 10px 15px; border-top: 1px solid var(--border-color);
            background-color: var(--chat-bg); transition: all 0.3s; flex-shrink: 0; align-items: center;
        }
        #micButton {
            padding: 8px 10px; margin-right: 8px; border-radius: 50%;
            background-color: transparent; border: 1px solid var(--input-border);
            color: var(--text-color); cursor: pointer; font-size: 1.1em;
        }
        #micButton:hover { background-color: var(--bot-msg-bg); }
        #micButton.recording { background-color: #ff4d4dcc; color: white; }

        #userInput {
            flex-grow: 1; padding: 10px 15px; border: 1px solid var(--input-border); border-radius: 20px;
            font-size: 1em; background-color: var(--input-bg); color: var(--input-text); transition: all 0.3s;
            margin-right: 8px;
        }
        #userInput:focus, #sendButton:focus, #theme-toggle:focus, #micButton:focus {
            outline: none; border-color: var(--button-bg); box-shadow: 0 0 0 3px var(--focus-ring);
        }
        #sendButton {
            padding: 10px 18px; background-color: var(--button-bg); color: var(--button-text);
            border: none; border-radius: 20px; cursor: pointer; font-size: 1em; font-weight: bold; transition: all 0.2s;
        }
        #sendButton:hover:not(:disabled) { opacity:0.85; }
        #sendButton:disabled { background-color:color-mix(in srgb,var(--button-bg) 40%,#88888890); cursor:not-allowed; opacity:.6; }

        .message pre { white-space: pre-wrap; background-color: #2d2d2d; color: #f0f0f0; padding: 10px; border-radius: 5px; margin: 5px 0; overflow-x: auto;}
        .message code { font-family: 'Courier New', Courier, monospace; }
        .message blockquote { border-left: 3px solid #ccc; padding-left: 10px; margin-left: 5px; color: #888; }
        .dark-mode .message pre { background-color: #1e1e1e; border: 1px solid #333; }
        .dark-mode .message blockquote { border-left-color: #555; color: #aaa; }

        .info-tooltip {
            display: inline-block; width: 14px; height: 14px;
            border-radius: 50%; background-color: var(--button-bg); color: var(--button-text);
            text-align: center; font-size: 10px; line-height: 14px;
            margin-left: 4px; cursor: help; user-select: none;
        }

        @media (min-width: 769px) { .threads-sidebar { display: flex; } }
        @media (max-width: 800px) { .chat-area { border-radius: 0; margin: 0; } }
    </style>
</head>
<body>
    <aside class="threads-sidebar" id="threadsSidebar">
        <h3>Chat Threads</h3>
        <ul id="threadList"></ul>
        <button id="newThreadButton" class="header-controls button">New Chat</button>
    </aside>
    <main class="chat-area">
        <div class="chat-container" id="chatAppContainer">
            <header class="chat-header">
                <h2>
                    <span class="title-main">AI Assistant</span>
                    <span class="title-subtitle">by Taylan</span>
                </h2>
                <div class="header-controls">
                    <label for="personaSelect">Persona:</label>
                    <select id="personaSelect">
                        <option value="helpful">Helpful Assistant</option>
                        <option value="friendly">Friendly Pal</option>
                        <option value="professional">Professional Expert</option>
                        <option value="sarcastic">Sarcastic Wit</option>
                        <option value="pirate">Pirate Captain</option>
                    </select>
                    <button id="exportChatButton" aria-label="Export chat">Export</button>
                    <button id="theme-toggle" aria-label="Toggle color theme">
                        <span class="icon"></span> <span class="text">Theme</span>
                    </button>
                </div>
            </header>

            <div class="suggestions-container" id="suggestionsContainer"></div>
            <div class="commands-suggestion-container" id="commandsSuggestionContainer" style="display: none;"></div>

            <div class="chat-window" id="chatWindow" role="log" aria-live="polite"></div>

            <form class="chat-input-form" id="chatForm">
                <button type="button" id="micButton" aria-label="Use microphone">üé§</button>
                <input type="text" id="userInput" placeholder="Ask me anything or type /help..." autocomplete="off" aria-label="User message input" role="textbox">
                <button type="submit" id="sendButton" aria-label="Send message">Send</button>
            </form>
        </div>
    </main>

<script defer>
document.addEventListener('DOMContentLoaded', () => {
    const chatAppContainer = document.getElementById('chatAppContainer');
    const chatWindow = document.getElementById('chatWindow');
    const userInput = document.getElementById('userInput');
    const chatForm = document.getElementById('chatForm');
    const sendButton = document.getElementById('sendButton'); // Correctly scoped
    const themeToggleButton = document.getElementById('theme-toggle');
    const themeToggleIcon = themeToggleButton.querySelector('.icon');
    const themeToggleText = themeToggleButton.querySelector('.text');
    const personaSelect = document.getElementById('personaSelect');
    const exportChatButton = document.getElementById('exportChatButton');
    const suggestionsContainer = document.getElementById('suggestionsContainer');
    const commandsSuggestionContainer = document.getElementById('commandsSuggestionContainer');
    const micButton = document.getElementById('micButton');
    const threadsSidebar = document.getElementById('threadsSidebar');
    const threadList = document.getElementById('threadList');
    const newThreadButton = document.getElementById('newThreadButton');

    let conversationHistory = [];
    let currentChatThreadId = localStorage.getItem('lastActiveThreadId') || 'default_chat';
    let userName = localStorage.getItem('userName') || null;
    let userPreferences = JSON.parse(localStorage.getItem('userPreferences') || '{}'); // For storing things like favorite color
    let aiTemperature = localStorage.getItem('aiTemperature') || "0.7"; // Default to a balanced value (string for consistency if backend expects it)
    let initialFocusDone = false;
    const MAX_MESSAGES_DISPLAY = 100;
    const MAX_CONTEXT_MESSAGES = 10; // Max messages to send as context
    let speechRecognition;
    let typingTimeout; // For GPT-style typing animation

    const AVAILABLE_COMMANDS = [
        { cmd: "/help", desc: "Show this help message." },
        { cmd: "/joke", desc: "Tell a joke." },
        { cmd: "/fact", desc: "Tell a fun fact (placeholder)." },
        { cmd: "/temp creative", desc: "Set AI to more creative (temp ~0.9)." },
        { cmd: "/temp balanced", desc: "Set AI to balanced (temp ~0.7)." },
        { cmd: "/temp precise", desc: "Set AI to more precise (temp ~0.3)." },
        { cmd: "/reset", desc: "Reset current chat (clears messages)." },
        { cmd: "/weather <city>", desc: "Get weather for a city (backend needed)." },
        { cmd: "/news <topic>", desc: "Get news on a topic (backend needed)." },
    ];

    // --- CORE FUNCTIONS ---
    function initializeChat() {
        loadTheme();
        applyViewportHeight();
        loadChatThreads(); 
        loadConversation(currentChatThreadId); 
        displaySuggestedPrompts(); 
        
        if (!conversationHistory.length && !document.querySelector('.message.bot')) { 
            const persona = personaSelect.value;
            const greeting = generateGreeting(persona);
            const greetingId = generateMessageId();
            addMessageToChat(greeting, 'bot', false, greetingId);
            updateConversationHistory('assistant', greeting, greetingId); // Update history after adding
        }
        
        if (!initialFocusDone) { userInput.focus(); initialFocusDone = true; }
        setTimeout(scrollToBottom, 100);
        updatePersonaSelectBasedOnThread(); // Set persona dropdown from loaded thread data
    }

    function generateGreeting(persona) {
        const namePart = userName ? ` ${userName}` : '';
        switch(persona) {
            case 'pirate': return `Ahoy Matey${namePart}! What treasures be ye seekin' today?`;
            case 'sarcastic': return `Oh, it's you${namePart}. Back for more, are we? What insightful query plagues you now?`;
            case 'friendly': return `Hey there${namePart}! ${userName ? 'So glad to see you again!' : 'Great to meet you!'} What's on your mind?`;
            case 'professional': return `Good day${namePart}. I am your Professional AI Assistant. How may I be of service?`;
            default: return `${userName ? `Welcome back, ${userName}!` : 'Hello!'} I'm your ${persona} AI Assistant. How can I help?`;
        }
    }
    
    function generateMessageId() { return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`; }

    // --- AI API INTEGRATION ---
    async function fetchAIResponseFromServer(promptText, history, persona, temperature, stream = false) {
        const endpoint = stream ? '/api/chat-stream' : '/api/chat';
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    prompt: promptText, 
                    history: history,
                    persona: persona,
                    temperature: parseFloat(temperature) // Ensure it's a number if backend expects float
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: "Unknown error occurred" }));
                console.error('API Error:', response.status, errorData);
                return `Error: ${errorData.detail || response.statusText}. (Is your backend server running and configured correctly?)`;
            }
            
            if (stream) { 
                return response.body.getReader();
            } else {
                const data = await response.json();
                return data.reply || "Sorry, I couldn't get a response from the AI.";
            }
        } catch (error) {
            console.error('Network or Fetch Error:', error);
            return "Network error. Could not reach the AI service. (Is your backend server running and configured?)";
        }
    }
    
    // --- STREAMING RESPONSE HANDLING ---
    async function handleStreamedResponse(reader, botMessageElement, botMessageId) {
        if (!reader) { // Fallback if reader is not available
            botMessageElement.innerHTML = DOMPurify.sanitize(typeof marked !== 'undefined' ? marked.parse("Error: Unable to stream response.") : "Error: Unable to stream response.");
            Prism.highlightAllUnder(botMessageElement);
            updateConversationHistory('assistant', "Error: Unable to stream response.", botMessageId);
            enableInputs();
            return;
        }

        const decoder = new TextDecoder();
        let fullText = '';
        userInput.disabled = true; 
        sendButton.disabled = true;
        let firstChunk = true;

        async function processChar(char) {
            return new Promise(resolve => {
                setTimeout(() => {
                    fullText += char;
                    botMessageElement.innerHTML = DOMPurify.sanitize(
                        (typeof marked !== 'undefined' ? marked.parse(fullText + (firstChunk ? '‚ñã' : '')) : fullText + (firstChunk ? '‚ñã' : ''))
                    );
                    scrollToBottom();
                    resolve();
                }, 10); // Adjust delay for typing speed
            });
        }
        
        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                
                for (const char of chunk) {
                    await processChar(char);
                }
                firstChunk = false; 
            }
        } catch (error) {
            console.error('Streaming error:', error);
            fullText += "\n\n[Error during streaming]";
        } finally {
            botMessageElement.innerHTML = DOMPurify.sanitize(
                (typeof marked !== 'undefined' ? marked.parse(fullText) : fullText)
            );
            Prism.highlightAllUnder(botMessageElement);
            updateConversationHistory('assistant', fullText, botMessageId);
            saveConversation(currentChatThreadId);
            enableInputs();
            userInput.focus();
        }
    }
    
    function enableInputs() {
        userInput.disabled = false;
        sendButton.disabled = false;
    }

    function sanitizeInput(text) { 
        // Basic sanitization if DOMPurify is not used for user input display (it is for bot output)
        const temp = document.createElement('div');
        temp.textContent = text;
        return temp.innerHTML;
    }

    function addMessageToChat(text, sender, isLoading = false, messageId) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', sender);
        messageElement.id = messageId;
        messageElement.setAttribute('aria-atomic', 'true');

        if (isLoading) {
            messageElement.classList.add('loading'); // Changed from 'typing' for clarity
            messageElement.innerHTML = `<div class="loading-spinner"></div> <span>Thinking...</span>`;
            messageElement.setAttribute('aria-label', 'Bot is thinking');
        } else {
            if (sender === 'user') {
                messageElement.textContent = text; // User text doesn't need Markdown parsing here
            } else { // Bot message with Markdown
                const htmlContent = typeof marked !== 'undefined' ? marked.parse(text) : text.replace(/\n/g, '<br>');
                messageElement.innerHTML = DOMPurify.sanitize(htmlContent, { USE_PROFILES: { html: true } });
                Prism.highlightAllUnder(messageElement); 
                addMessageActions(messageElement, text, messageId); 
                addInfoTooltipsToMessage(messageElement, text); 
            }
        }
        
        chatWindow.appendChild(messageElement);
        pruneOldMessagesDOM();
        scrollToBottom();
        if (!isLoading && sender === 'bot') {
            chatAppContainer.classList.remove('flash');
            void chatAppContainer.offsetWidth; // Trigger reflow
            chatAppContainer.classList.add('flash');
        }
        return messageElement;
    }

    function addMessageActions(messageElement, originalText, messageId) {
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'message-actions';

        const speakButton = document.createElement('button');
        speakButton.innerHTML = 'üîä';
        speakButton.title = 'Read aloud';
        speakButton.onclick = () => speakText(originalText);
        actionsContainer.appendChild(speakButton);

        const rephraseButton = document.createElement('button');
        rephraseButton.innerHTML = 'üîÅ';
        rephraseButton.title = 'Rephrase this';
        rephraseButton.onclick = () => handleRephraseMessage(originalText, messageId);
        actionsContainer.appendChild(rephraseButton);
        
        messageElement.appendChild(actionsContainer);
    }
    
    function speakText(text) {
        if (!('speechSynthesis' in window)) {
            alert("Sorry, your browser doesn't support text-to-speech.");
            return;
        }
        // Strip markdown for cleaner speech
        const plainText = DOMPurify.sanitize(text, { ALLOWED_TAGS: [] }).replace(/[*_`~#>|]/g, '');
        const utterance = new SpeechSynthesisUtterance(plainText);
        utterance.lang = 'en-US'; 
        speechSynthesis.cancel(); 
        speechSynthesis.speak(utterance);
    }

    function setupSpeechRecognition() {
        if ('webkitSpeechRecognition' in window) {
            speechRecognition = new webkitSpeechRecognition();
            speechRecognition.continuous = false; 
            speechRecognition.interimResults = false;
            speechRecognition.lang = 'en-US';

            speechRecognition.onstart = () => {
                micButton.classList.add('recording');
                micButton.textContent = 'üéôÔ∏è';
                userInput.placeholder = "Listening...";
            };
            speechRecognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                userInput.value = transcript;
                // Optionally auto-send: handleSendMessage(); 
            };
            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                userInput.placeholder = "Mic error. Try typing.";
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    alert("Microphone access denied. Please enable it in your browser settings.");
                }
            };
            speechRecognition.onend = () => {
                micButton.classList.remove('recording');
                micButton.textContent = 'üé§';
                userInput.placeholder = "Ask me anything or type /help...";
                userInput.focus();
            };
        } else {
            micButton.style.display = 'none'; 
            console.warn("Speech recognition not supported in this browser.");
        }
    }
    micButton.addEventListener('click', () => {
        if (speechRecognition) {
            try {
                if (micButton.classList.contains('recording')) {
                    speechRecognition.stop();
                } else {
                    speechRecognition.start();
                }
            } catch(e) {
                console.error("Could not start/stop speech recognition: ", e);
                micButton.classList.remove('recording');
                micButton.textContent = 'üé§';
            }
        } else {
            alert("Speech recognition is not available.");
        }
    });
    
    exportChatButton.addEventListener('click', () => {
        const chatData = {
            threadId: currentChatThreadId,
            persona: personaSelect.value,
            history: conversationHistory,
            exportedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(chatData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `chat_export_${currentChatThreadId}_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    });

    function loadChatThreads() {
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        threadList.innerHTML = ''; 
        if (Object.keys(threads).length === 0) {
            threads['default_chat'] = { name: 'General Chat', lastUpdated: Date.now(), history: [], persona: 'helpful' };
            localStorage.setItem('chatThreads', JSON.stringify(threads));
        }
        currentChatThreadId = localStorage.getItem('lastActiveThreadId') || Object.keys(threads)[0];
        if (!threads[currentChatThreadId]) { // Ensure currentChatThreadId is valid
            currentChatThreadId = Object.keys(threads)[0];
            localStorage.setItem('lastActiveThreadId', currentChatThreadId);
        }
        
        Object.entries(threads).sort(([,a],[,b]) => b.lastUpdated - a.lastUpdated).forEach(([threadId, thread]) => {
            const li = document.createElement('li');
            const button = document.createElement('button');
            button.textContent = thread.name || `Chat ${threadId.substring(0,5)}`;
            button.dataset.threadId = threadId;
            if (threadId === currentChatThreadId) button.classList.add('active');
            button.onclick = () => switchChatThread(threadId);
            li.appendChild(button);
            threadList.appendChild(li);
        });
    }

    function switchChatThread(threadId) {
        saveConversation(currentChatThreadId); 
        currentChatThreadId = threadId;
        localStorage.setItem('lastActiveThreadId', currentChatThreadId);
        loadConversation(threadId);
        document.querySelectorAll('#threadList button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.threadId === threadId);
        });
        updatePersonaSelectBasedOnThread();
    }

    newThreadButton.addEventListener('click', () => {
        const newThreadName = prompt("Enter name for new chat thread:", `Chat Session ${Object.keys(JSON.parse(localStorage.getItem('chatThreads') || '{}')).length + 1}`);
        if (newThreadName) {
            saveConversation(currentChatThreadId); 
            const newThreadId = `thread_${Date.now()}`;
            const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
            threads[newThreadId] = { name: newThreadName, lastUpdated: Date.now(), history: [], persona: personaSelect.value };
            localStorage.setItem('chatThreads', JSON.stringify(threads));
            currentChatThreadId = newThreadId;
            localStorage.setItem('lastActiveThreadId', currentChatThreadId);
            loadChatThreads(); // Refresh sidebar and sort
            loadConversation(newThreadId); // Load the new empty chat
            updatePersonaSelectBasedOnThread();
        }
    });
    
    function updatePersonaSelectBasedOnThread() {
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        const currentThread = threads[currentChatThreadId];
        if (currentThread && currentThread.persona) {
            personaSelect.value = currentThread.persona;
        }
    }

    personaSelect.addEventListener('change', () => {
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        if (threads[currentChatThreadId]) {
            threads[currentChatThreadId].persona = personaSelect.value;
            localStorage.setItem('chatThreads', JSON.stringify(threads));
        }
        // Optionally, give a small feedback or greeting change.
        const newGreeting = generateGreeting(personaSelect.value);
        addMessageToChat(`Switched to ${personaSelect.value} persona. ${newGreeting}`, 'bot', false, generateMessageId());
        updateConversationHistory('assistant', `Switched to ${personaSelect.value} persona. ${newGreeting}`, generateMessageId());
    });


    function saveConversation(threadId) {
        if (!threadId) return;
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        if (!threads[threadId]) threads[threadId] = { name: `Chat ${threadId.substring(0,5)}`, history: [], persona: personaSelect.value };
        threads[threadId].history = conversationHistory;
        threads[threadId].lastUpdated = Date.now();
        threads[threadId].persona = personaSelect.value; // Save current persona with the thread
        localStorage.setItem('chatThreads', JSON.stringify(threads));
    }

    function loadConversation(threadId) {
        if (!threadId) threadId = 'default_chat';
        currentChatThreadId = threadId;
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        const thread = threads[threadId];
        
        chatWindow.innerHTML = ''; 
        if (thread && thread.history) {
            conversationHistory = thread.history;
            personaSelect.value = thread.persona || 'helpful'; // Load persona
            conversationHistory.forEach(msg => addMessageToChat(msg.content, msg.role, false, msg.id || generateMessageId()));
        } else {
            conversationHistory = []; 
            personaSelect.value = 'helpful'; // Default persona for new/empty threads
        }
        scrollToBottom();
    }

    function displaySuggestedPrompts() {
        const suggestions = [
            "Tell me a fun fact.", "Explain quantum computing simply.", 
            "What's the weather like in Paris?", "Draft an email to my boss.",
            "Suggest a recipe for dinner.", "/joke"
        ];
        suggestionsContainer.innerHTML = ''; 
        suggestions.forEach(text => {
            const btn = document.createElement('button');
            btn.textContent = text;
            btn.onclick = () => {
                userInput.value = text;
                handleSendMessage();
                suggestionsContainer.style.display = 'none'; 
            };
            suggestionsContainer.appendChild(btn);
        });
    }
    userInput.addEventListener('focus', () => { 
        if(conversationHistory.length <= 1 && userInput.value === '') suggestionsContainer.style.display = 'flex'; 
        commandsSuggestionContainer.style.display = 'none';
    });
    userInput.addEventListener('blur', () => {
        // Delay hiding suggestions to allow click
        setTimeout(() => {
            if (!commandsSuggestionContainer.contains(document.activeElement)) { // only hide if focus isn't on a suggestion
                 commandsSuggestionContainer.style.display = 'none';
            }
            if (!suggestionsContainer.contains(document.activeElement)) {
                 suggestionsContainer.style.display = 'none';
            }
        }, 150);
    });

    userInput.addEventListener('input', () => {
        const text = userInput.value;
        if (text.startsWith('/') && text.length >=1) {
            const searchTerm = text.substring(1).toLowerCase();
            const filteredCommands = AVAILABLE_COMMANDS.filter(cmdObj => cmdObj.cmd.substring(1).startsWith(searchTerm));
            displayCommandSuggestions(filteredCommands);
            suggestionsContainer.style.display = 'none';
        } else {
            commandsSuggestionContainer.style.display = 'none';
            if (conversationHistory.length <= 1 && text === '') {
                suggestionsContainer.style.display = 'flex';
            } else {
                suggestionsContainer.style.display = 'none';
            }
        }
    });

    function displayCommandSuggestions(commands) {
        commandsSuggestionContainer.innerHTML = '';
        if (commands.length > 0) {
            commands.forEach(cmdObj => {
                const btn = document.createElement('button');
                btn.textContent = `${cmdObj.cmd} - ${cmdObj.desc}`;
                btn.onclick = () => {
                    userInput.value = cmdObj.cmd + (cmdObj.cmd.includes('<') ? ' ' : ''); // Add space if it expects param
                    commandsSuggestionContainer.style.display = 'none';
                    userInput.focus();
                    if (!cmdObj.cmd.includes('<')) { // Auto-send if no params needed
                        handleSendMessage();
                    }
                };
                commandsSuggestionContainer.appendChild(btn);
            });
            commandsSuggestionContainer.style.display = 'flex';
        } else {
            commandsSuggestionContainer.style.display = 'none';
        }
    }


    function detectEmotion(text) {
        const lowerText = text.toLowerCase();
        if (/\b(angry|furious|pissed off|annoyed|frustrated|hate)\b/i.test(lowerText)) return "angry";
        if (/\b(sad|upset|crying|depressed|miserable)\b/i.test(lowerText)) return "sad";
        if (/\b(happy|excited|yay|great|awesome|love it)\b/i.test(lowerText)) return "happy";
        if (/\b(confused|huh|what\?|don't understand)\b/i.test(lowerText)) return "confused";
        return "neutral";
    }
    
    function handleEmotionalResponse(emotion, userMessage) {
        // This is a placeholder. Could modify system prompt for next AI call,
        // or add a specific client-side message.
        console.log(`User emotion detected: ${emotion} for message: "${userMessage}"`);
        let responsePrefix = "";
        if (emotion === "sad") {
            responsePrefix = "I'm sorry to hear you're feeling sad. ";
        } else if (emotion === "angry") {
            responsePrefix = "I understand you might be feeling angry. ";
        } else if (emotion === "happy") {
            responsePrefix = "That's great to hear! ";
        }
        // if (responsePrefix) {
        //     addMessageToChat(responsePrefix + "How can I assist you further?", 'bot', false, generateMessageId());
        // }
    }


    function addInfoTooltipsToMessage(messageElement, text) {
        const knownFacts = { 
            "Paris": "The capital city of France, known for the Eiffel Tower.", 
            "GPT-4": "A large language model developed by OpenAI.",
            "Quantum Computing": "A type of computation that harnesses quantum phenomena like superposition and entanglement."
        };
        let html = messageElement.innerHTML;
        for (const fact in knownFacts) {
            if (text.toLowerCase().includes(fact.toLowerCase())) { // Case-insensitive check in text
                // Regex to match whole word, case-insensitive, but replace preserving case
                const regex = new RegExp(`\\b(${fact})\\b`, 'gi'); 
                html = html.replace(regex, (match) => `${match} <span class="info-tooltip" title="${knownFacts[fact]}">‚ÑπÔ∏è</span>`);
            }
        }
        messageElement.innerHTML = html; // Apply all changes at once
    }
    
    async function handleRephraseMessage(originalText, originalMessageId) {
        const userPrompt = `Please rephrase the following text in a slightly different way: "${originalText}"`;
        addMessageToChat(`(Attempting to rephrase...)`, 'user', false, generateMessageId());
        
        const loadingIndicator = addMessageToChat('', 'bot', true, generateMessageId());
        const rephrasedText = await fetchAIResponseFromServer(userPrompt, [], personaSelect.value, aiTemperature); // Minimal history for rephrase
        loadingIndicator.remove();
        
        const originalMsgElement = document.getElementById(originalMessageId);
        const rephraseMsgId = generateMessageId();

        if (originalMsgElement && !rephrasedText.toLowerCase().startsWith("error:")) {
             originalMsgElement.innerHTML = DOMPurify.sanitize(typeof marked !== 'undefined' ? marked.parse(`(Original): ${originalText}<hr>(Rephrased): ${rephrasedText}`) : `(Original): ${originalText}<hr>(Rephrased): ${rephrasedText}`);
             Prism.highlightAllUnder(originalMsgElement);
             // Update the history for the original message
             const msgIndex = conversationHistory.findIndex(msg => msg.id === originalMessageId);
             if (msgIndex !== -1) {
                conversationHistory[msgIndex].content = `(Original): ${originalText}\n(Rephrased): ${rephrasedText}`;
             }
        } else { 
            addMessageToChat(rephrasedText.startsWith("Error:") ? rephrasedText : `(Rephrased): ${rephrasedText}`, 'bot', false, rephraseMsgId);
            updateConversationHistory('assistant', rephrasedText.startsWith("Error:") ? rephrasedText : `(Rephrased): ${rephrasedText}`, rephraseMsgId);
        }
        saveConversation(currentChatThreadId);
    }
    
    function extractAndStoreUserPreferences(promptText) {
        const lowerPrompt = promptText.toLowerCase();
        let nameFound = null;
        if (lowerPrompt.includes("my name is ")) {
            nameFound = lowerPrompt.split("my name is ")[1].split(/[\s,.!?]/)[0];
        } else if (lowerPrompt.includes("call me ")) {
            nameFound = lowerPrompt.split("call me ")[1].split(/[\s,.!?]/)[0];
        }
        if (nameFound) {
            userName = nameFound.charAt(0).toUpperCase() + nameFound.slice(1);
            localStorage.setItem('userName', userName); 
            console.log("Username stored:", userName);
            addMessageToChat(`Got it, I'll call you ${userName}!`, 'bot', false, generateMessageId());
        }

        const colorMatch = lowerPrompt.match(/my favorite colou?r is (\w+)/);
        if (colorMatch && colorMatch[1]) {
            userPreferences.favoriteColor = colorMatch[1];
            localStorage.setItem('userPreferences', JSON.stringify(userPreferences));
            addMessageToChat(`Nice! ${userPreferences.favoriteColor.charAt(0).toUpperCase() + userPreferences.favoriteColor.slice(1)} is a great color. I'll remember that.`, 'bot', false, generateMessageId());
        }
    }

    function suggestPersonaChange(messageText) {
        const lowerText = messageText.toLowerCase();
        let newPersona = null;
        if (lowerText.includes("make it funny") || lowerText.includes("tell me a joke") || lowerText.includes("be sarcastic")) {
            newPersona = "sarcastic";
        } else if (lowerText.includes("be serious") || lowerText.includes("formal response") || lowerText.includes("professional")) {
            newPersona = "professional";
        }

        if (newPersona && personaSelect.value !== newPersona) {
            const suggestionId = generateMessageId();
            const suggestionMsg = addMessageToChat(`I can switch to my ${newPersona} persona for that if you'd like. <button data-persona="${newPersona}" class="persona-suggestion-btn">Switch to ${newPersona}</button>`, 'bot', false, suggestionId);
            suggestionMsg.querySelector('.persona-suggestion-btn').addEventListener('click', (e) => {
                personaSelect.value = e.target.dataset.persona;
                personaSelect.dispatchEvent(new Event('change')); // Trigger change event
                e.target.closest('.message').remove(); // Remove suggestion message
                const historyIndex = conversationHistory.findIndex(msg => msg.id === suggestionId);
                if(historyIndex > -1) conversationHistory.splice(historyIndex, 1);

            });
        }
    }


    function updateConversationHistory(role, content, id, replace = false) {
        if (replace) {
            const existingMsgIndex = conversationHistory.findIndex(msg => msg.id === id);
            if (existingMsgIndex !== -1) {
                conversationHistory[existingMsgIndex] = { role, content, id };
                return;
            }
        }
        // Prevent duplicate greetings or system messages if any
        if (conversationHistory.some(msg => msg.id === id)) return;
        conversationHistory.push({ role, content, id });
    }
    
    async function handleCommand(commandText) {
        const [command, ...args] = commandText.substring(1).toLowerCase().split(' ');
        const fullArg = args.join(' ');
        let commandProcessed = true;
        let botResponse = "";

        switch(command) {
            case 'help':
                botResponse = "Available commands:\n" + AVAILABLE_COMMANDS.map(c => `${c.cmd} - ${c.desc}`).join('\n');
                break;
            case 'joke':
                const jokes = [
                    "Why don't scientists trust atoms? Because they make up everything!",
                    "Why did the scarecrow win an award? Because he was outstanding in his field!",
                    "Why don't robots panic? They have nerves of steel!"
                ];
                botResponse = jokes[Math.floor(Math.random() * jokes.length)];
                break;
            case 'fact': // Placeholder
                botResponse = "Here's a fun fact (placeholder): The sky is blue... usually!";
                // In a real scenario, you'd call an API here.
                // botResponse = await fetchFactFromAPI(); 
                break;
            case 'temp':
                if (args.length > 0) {
                    const tempArg = args[0];
                    if (tempArg === 'creative') aiTemperature = "0.9";
                    else if (tempArg === 'balanced') aiTemperature = "0.7";
                    else if (tempArg === 'precise') aiTemperature = "0.3";
                    else {
                        botResponse = "Usage: /temp [creative|balanced|precise]";
                        break;
                    }
                    localStorage.setItem('aiTemperature', aiTemperature);
                    botResponse = `AI temperature set to ${tempArg} (value: ${aiTemperature}).`;
                } else {
                    botResponse = `Current AI temperature is ${aiTemperature}. Use /temp [creative|balanced|precise] to change.`;
                }
                break;
            case 'reset':
                chatWindow.innerHTML = '';
                conversationHistory = [];
                const currentPersonaForReset = personaSelect.value;
                const greetingForReset = generateGreeting(currentPersonaForReset);
                const greetingIdForReset = generateMessageId();
                addMessageToChat(greetingForReset, 'bot', false, greetingIdForReset);
                updateConversationHistory('assistant', greetingForReset, greetingIdForReset);
                saveConversation(currentChatThreadId); // Save the cleared state
                botResponse = "Chat reset."; // This message won't show as chat is cleared above, but good for logging.
                break;
            case 'weather':
            case 'news':
                // These require backend integration
                botResponse = `The /${command} command is not fully implemented yet. It requires backend integration to fetch real data for "${fullArg}".`;
                // Example of how you might structure the call if backend was ready:
                // commandProcessed = false; // Let normal AI handle it if you want to phrase it as a question.
                // For now, just a message.
                break;

            default:
                commandProcessed = false; // Not a recognized client-side command
        }

        if (commandProcessed && botResponse) {
            const botMessageId = generateMessageId();
            addMessageToChat(botResponse, 'bot', false, botMessageId);
            updateConversationHistory('assistant', botResponse, botMessageId);
            saveConversation(currentChatThreadId);
        }
        return commandProcessed;
    }


    async function handleSendMessage(event) {
        if (event) event.preventDefault();
        const messageText = userInput.value.trim();
        if (messageText === '') return;

        userInput.value = ''; // Clear input early
        suggestionsContainer.style.display = 'none'; 
        commandsSuggestionContainer.style.display = 'none';


        const userMessageId = generateMessageId();
        addMessageToChat(messageText, 'user', false, userMessageId);
        updateConversationHistory('user', messageText, userMessageId);
        
        extractAndStoreUserPreferences(messageText); 
        suggestPersonaChange(messageText); // Suggest persona change based on user input

        const userEmotion = detectEmotion(messageText);
        handleEmotionalResponse(userEmotion, messageText);


        if (messageText.startsWith('/')) {
            const commandProcessed = await handleCommand(messageText);
            if (commandProcessed) {
                scrollToBottom();
                userInput.focus();
                return; // Command handled, no AI call needed
            }
            // If not processed, it might be a prompt that starts with /
        }


        const currentPersona = personaSelect.value;
        const loadingIndicator = addMessageToChat('', 'bot', true, generateMessageId()); // Use isLoading class
        sendButton.disabled = true;
        userInput.disabled = true;

        const useStreaming = true; 
        const historyForAI = conversationHistory.slice(-MAX_CONTEXT_MESSAGES -1, -1); // Get last N messages, excluding current user prompt

        if (useStreaming) { 
            const reader = await fetchAIResponseFromServer(messageText, historyForAI, currentPersona, aiTemperature, true);
            loadingIndicator.remove(); 
            if (typeof reader === 'string') { // Error occurred, reader is the error message
                const botMessageId = generateMessageId();
                addMessageToChat(reader, 'bot', false, botMessageId);
                updateConversationHistory('assistant', reader, botMessageId);
                enableInputs();
            } else { 
                const botMessageId = generateMessageId();
                const botMessageElement = addMessageToChat('', 'bot', false, botMessageId); 
                botMessageElement.innerHTML = '‚ñã'; // Initial cursor before streaming starts
                await handleStreamedResponse(reader, botMessageElement, botMessageId);
                // History updated within handleStreamedResponse, inputs re-enabled there
            }
        } else { 
            const aiResponseText = await fetchAIResponseFromServer(messageText, historyForAI, currentPersona, aiTemperature);
            loadingIndicator.remove();
            const botMessageId = generateMessageId();
            addMessageToChat(aiResponseText, 'bot', false, botMessageId);
            updateConversationHistory('assistant', aiResponseText, botMessageId);
            enableInputs();
        }
        saveConversation(currentChatThreadId); 
    }

    function scrollToBottom() { if(chatWindow) setTimeout(() => { chatWindow.scrollTop = chatWindow.scrollHeight; },0); }
    function pruneOldMessagesDOM() {
        while (chatWindow.children.length > MAX_MESSAGES_DISPLAY) {
            chatWindow.removeChild(chatWindow.firstChild);
        }
    }
    function applyViewportHeight() { 
        const setHeight = () => {
            if(document.querySelector('.chat-area')) {
                 document.querySelector('.chat-area').style.height = window.innerHeight + 'px';
            }
        };
        setHeight();
        window.addEventListener('resize', setHeight);
    }
    function loadTheme() { 
        const savedTheme = localStorage.getItem('theme');
        document.body.classList.toggle('dark-mode', savedTheme === 'dark');
        updateThemePreference();
    }
    function updateThemePreference() { 
        const isDarkMode = document.body.classList.contains('dark-mode');
        if (themeToggleIcon) themeToggleIcon.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô'; // Sun for dark, moon for light
        if (themeToggleText) themeToggleText.textContent = isDarkMode ? 'Light' : 'Dark';
        localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
    }
    
    chatForm.addEventListener('submit', handleSendMessage);
    themeToggleButton.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        updateThemePreference();
    });

    initializeChat();
    setupSpeechRecognition(); 
});
</script>

</body>
</html>
