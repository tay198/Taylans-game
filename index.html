<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>AI ChatBot by Taylan - Advanced (Frontend Gemini)</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" data-manual></script>
    <style>
        /* ... (Your existing CSS styles remain unchanged) ... */
        :root {
            --body-bg-light: #f4f6f8; --body-bg-dark: #0d1117;
            --chat-bg-light: #ffffff; --chat-bg-dark: #161b22;
            --header-bg-light: #007bff; --header-bg-dark: #1f6feb;
            --header-text-light: #ffffff; --header-text-dark: #c9d1d9;
            --user-msg-bg-light: #007bff; --user-msg-bg-dark: #1f6feb;
            --user-msg-text-light: #ffffff; --user-msg-text-dark: #e0e0e0;
            --bot-msg-bg-light: #e9ecef; --bot-msg-bg-dark: #21262d;
            --bot-msg-text-light: #333333; --bot-msg-text-dark: #c9d1d9;
            --input-bg-light: #ffffff; --input-bg-dark: #0d1117;
            --input-text-light: #333333; --input-text-dark: #c9d1d9;
            --input-border-light: #ced4da; --input-border-dark: #30363d;
            --button-bg-light: #007bff; --button-bg-dark: #238636;
            --button-text-light: #ffffff; --button-text-dark: #ffffff;
            --text-color-light: #212529; --text-color-dark: #c9d1d9;
            --border-color-light: #dee2e6; --border-color-dark: #30363d;
            --shadow-light: 0 2px 10px rgba(0,0,0,0.075); --shadow-dark: 0 3px 12px rgba(0,0,0,0.25);
            --focus-ring-light: rgba(0,123,255,0.25); --focus-ring-dark: rgba(31,111,235,0.4);
            --suggestion-bg-light: #e0e0e0; --suggestion-bg-dark: #2a2a2a;
            --suggestion-text-light: #333; --suggestion-text-dark: #ccc;
            --body-bg: var(--body-bg-light); --chat-bg: var(--chat-bg-light);
            --header-bg: var(--header-bg-light); --header-text: var(--header-text-light);
            --user-msg-bg: var(--user-msg-bg-light); --user-msg-text: var(--user-msg-text-light);
            --bot-msg-bg: var(--bot-msg-bg-light); --bot-msg-text: var(--bot-msg-text-light);
            --input-bg: var(--input-bg-light); --input-text: var(--input-text-light);
            --input-border: var(--input-border-light); --button-bg: var(--button-bg-light);
            --button-text: var(--button-text-light); --text-color: var(--text-color-light);
            --border-color: var(--border-color-light); --shadow: var(--shadow-light);
            --focus-ring: var(--focus-ring-light);
            --suggestion-bg: var(--suggestion-bg-light); --suggestion-text: var(--suggestion-text-light);
        }
        body.dark-mode {
            --body-bg: var(--body-bg-dark); --chat-bg: var(--chat-bg-dark);
            --header-bg: var(--header-bg-dark); --header-text: var(--header-text-dark);
            --user-msg-bg: var(--user-msg-bg-dark); --user-msg-text: var(--user-msg-text-dark);
            --bot-msg-bg: var(--bot-msg-bg-dark); --bot-msg-text: var(--bot-msg-text-dark);
            --input-bg: var(--input-bg-dark); --input-text: var(--input-text-dark);
            --input-border: var(--input-border-dark); --button-bg: var(--button-bg-dark);
            --button-text: var(--button-text-dark); --text-color: var(--text-color-dark);
            --border-color: var(--border-color-dark); --shadow: var(--shadow-dark);
            --focus-ring: var(--focus-ring-dark);
            --suggestion-bg: var(--suggestion-bg-dark); --suggestion-text: var(--suggestion-text-dark);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        html { height: 100%; }
        body {
            background-color: var(--body-bg); color: var(--text-color);
            display: flex; flex-direction: row; 
            min-height: 100%; transition: background-color 0.3s, color 0.3s;
        }

        .threads-sidebar {
            width: 250px;
            background-color: var(--chat-bg);
            border-right: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, border-color 0.3s;
            display: none; 
        }
        .threads-sidebar h3 { margin-bottom: 10px; font-size: 1.1em; color: var(--text-color); }
        .threads-sidebar ul { list-style: none; }
        .threads-sidebar li button { 
            width: 100%; text-align: left; padding: 8px; margin-bottom: 5px;
            background: none; border: 1px solid transparent; color: var(--text-color);
            border-radius: 5px; cursor: pointer;
        }
        .threads-sidebar li button:hover, .threads-sidebar li button.active {
            background-color: var(--bot-msg-bg); border-color: var(--button-bg);
        }
        #newThreadButton { margin-top: auto; padding: 10px; }

        .chat-area { 
            flex-grow: 1; 
            display: flex; flex-direction: column;
            height: 100vh; 
            height: 100dvh; 
        }

        .chat-container { 
            width: 100%;
            max-width: 100%; 
            flex-grow: 1; 
            background-color: var(--chat-bg);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s;
        }
        .chat-container.flash { animation: subtleBackgroundFlash 0.5s ease-out forwards; }
        @keyframes subtleBackgroundFlash {
            0% { background-color: var(--chat-bg); }
            25% { background-color: color-mix(in srgb, var(--chat-bg) 95%, var(--button-bg) 5%); }
            100% { background-color: var(--chat-bg); }
        }

        .chat-header {
            padding: 10px 15px; background-color: var(--header-bg); color: var(--header-text);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color); transition: all 0.3s; flex-shrink: 0;
        }
        .chat-header h2 { font-size: 1.1em; margin: 0; display: flex; flex-direction: column; align-items: flex-start; }
        .chat-header h2 .title-main { line-height: 1; }
        .chat-header h2 .title-subtitle { font-size: 0.65em; font-weight: normal; opacity: 0.85; margin-top: 2px; line-height: 1; }
        
        .header-controls { display: flex; align-items: center; gap: 10px; }
        .header-controls label { font-size: 0.8em; }
        .header-controls select, .header-controls button {
            padding: 5px 8px; border-radius: 5px; border: 1px solid var(--header-text);
            background-color: var(--header-bg); color: var(--header-text); font-size: 0.8em;
        }
        .header-controls button:hover { background-color: var(--header-text); color: var(--header-bg); }

        .chat-window {
            flex-grow: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px;
            scrollbar-width: thin; scrollbar-color: var(--button-bg) var(--chat-bg);
        }
        .chat-window::-webkit-scrollbar { width: 8px; }
        .chat-window::-webkit-scrollbar-track { background: var(--chat-bg); }
        .chat-window::-webkit-scrollbar-thumb { background-color: var(--button-bg); border-radius: 10px; border: 2px solid var(--chat-bg); }

        .message {
            padding: 10px 15px; border-radius: 18px; max-width: 80%; line-height: 1.5;
            opacity: 0; transform: translateY(10px); animation: fadeInMessage 0.4s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
            word-wrap: break-word; position: relative; 
        }
        @keyframes fadeInMessage { 0% { opacity: 0; transform: translateY(15px) scale(0.95); } 100% { opacity: 1; transform: translateY(0) scale(1); } }
        .message.fade-out { animation: fadeOutMessage 0.3s ease forwards; }
        @keyframes fadeOutMessage { to { opacity: 0; transform: translateY(-5px); height: 0; padding:0; margin:0; border:0; } }

        .message.user { background-color: var(--user-msg-bg); color: var(--user-msg-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .message.bot { background-color: var(--bot-msg-bg); color: var(--bot-msg-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        
        .message-actions { 
            position: absolute; bottom: -5px; right: -5px; display: none; gap: 3px;
            background-color: var(--chat-bg); padding:3px; border-radius: 5px; box-shadow: var(--shadow);
        }
        .message:hover .message-actions { display: flex; }
        .message-actions button { background: none; border: none; cursor: pointer; font-size: 0.9em; padding: 3px; }
        .message-actions button:hover { opacity: 0.7; }

        /* Typing indicator / Loading spinner */
        .message.bot.loading { 
            display: flex; align-items: center;
            background-color: var(--bot-msg-bg);
            color: var(--bot-msg-text);
            padding: 10px 15px;
            border-radius: 18px;
            border-bottom-left-radius: 5px;
            align-self: flex-start;
        }
        .loading-spinner {
            width: 20px; height: 20px;
            border: 3px solid currentColor;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }


        .suggestions-container, .commands-suggestion-container {
            padding: 5px 15px 10px; display: flex; flex-wrap: wrap; gap: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .suggestions-container button, .commands-suggestion-container button {
            padding: 6px 10px; border-radius: 15px; border: 1px solid var(--input-border);
            background-color: var(--suggestion-bg); color: var(--suggestion-text);
            font-size: 0.85em; cursor: pointer; transition: background-color 0.2s;
        }
        .suggestions-container button:hover, .commands-suggestion-container button:hover { opacity: 0.8; }
        .commands-suggestion-container { border-top: 1px solid var(--border-color); border-bottom: none; padding-top:10px; }


        .chat-input-form {
            display: flex; padding: 10px 15px; border-top: 1px solid var(--border-color);
            background-color: var(--chat-bg); transition: all 0.3s; flex-shrink: 0; align-items: center;
        }
        #micButton {
            padding: 8px 10px; margin-right: 8px; border-radius: 50%;
            background-color: transparent; border: 1px solid var(--input-border);
            color: var(--text-color); cursor: pointer; font-size: 1.1em;
        }
        #micButton:hover { background-color: var(--bot-msg-bg); }
        #micButton.recording { background-color: #ff4d4dcc; color: white; }

        #userInput {
            flex-grow: 1; padding: 10px 15px; border: 1px solid var(--input-border); border-radius: 20px;
            font-size: 1em; background-color: var(--input-bg); color: var(--input-text); transition: all 0.3s;
            margin-right: 8px;
        }
        #userInput:focus, #sendButton:focus, #theme-toggle:focus, #micButton:focus {
            outline: none; border-color: var(--button-bg); box-shadow: 0 0 0 3px var(--focus-ring);
        }
        #sendButton {
            padding: 10px 18px; background-color: var(--button-bg); color: var(--button-text);
            border: none; border-radius: 20px; cursor: pointer; font-size: 1em; font-weight: bold; transition: all 0.2s;
        }
        #sendButton:hover:not(:disabled) { opacity:0.85; }
        #sendButton:disabled { background-color:color-mix(in srgb,var(--button-bg) 40%,#88888890); cursor:not-allowed; opacity:.6; }

        .message pre { white-space: pre-wrap; background-color: #2d2d2d; color: #f0f0f0; padding: 10px; border-radius: 5px; margin: 5px 0; overflow-x: auto;}
        .message code { font-family: 'Courier New', Courier, monospace; }
        .message blockquote { border-left: 3px solid #ccc; padding-left: 10px; margin-left: 5px; color: #888; }
        .dark-mode .message pre { background-color: #1e1e1e; border: 1px solid #333; }
        .dark-mode .message blockquote { border-left-color: #555; color: #aaa; }

        .info-tooltip {
            display: inline-block; width: 14px; height: 14px;
            border-radius: 50%; background-color: var(--button-bg); color: var(--button-text);
            text-align: center; font-size: 10px; line-height: 14px;
            margin-left: 4px; cursor: help; user-select: none;
        }

        @media (min-width: 769px) { .threads-sidebar { display: flex; } }
        @media (max-width: 800px) { .chat-area { border-radius: 0; margin: 0; } }
    </style>
</head>
<body>
    <aside class="threads-sidebar" id="threadsSidebar">
        <h3>Chat Threads</h3>
        <ul id="threadList"></ul>
        <button id="newThreadButton" class="header-controls button">New Chat</button>
    </aside>
    <main class="chat-area">
        <div class="chat-container" id="chatAppContainer">
            <header class="chat-header">
                <h2>
                    <span class="title-main">AI Assistant</span>
                    <span class="title-subtitle">by Taylan</span> </h2>
                <div class="header-controls">
                    <label for="personaSelect">Persona:</label>
                    <select id="personaSelect">
                        <option value="helpful">Helpful Assistant</option>
                        <option value="friendly">Friendly Pal</option>
                        <option value="professional">Professional Expert</option>
                        <option value="sarcastic">Sarcastic Wit</option>
                        <option value="pirate">Pirate Captain</option>
                    </select>
                    <button id="exportChatButton" aria-label="Export chat">Export</button>
                    <button id="theme-toggle" aria-label="Toggle color theme">
                        <span class="icon"></span> <span class="text">Theme</span>
                    </button>
                </div>
            </header>

            <div class="suggestions-container" id="suggestionsContainer"></div>
            <div class="commands-suggestion-container" id="commandsSuggestionContainer" style="display: none;"></div>

            <div class="chat-window" id="chatWindow" role="log" aria-live="polite"></div>

            <form class="chat-input-form" id="chatForm">
                <button type="button" id="micButton" aria-label="Use microphone">üé§</button>
                <input type="text" id="userInput" placeholder="Ask me anything or type /help..." autocomplete="off" aria-label="User message input" role="textbox">
                <button type="submit" id="sendButton" aria-label="Send message">Send</button>
            </form>
        </div>
    </main>

<script type="module" defer>
    // 1. Import the GoogleGenerativeAI library
    import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "https://esm.run/@google/generative-ai";

    // --- DOM Elements ---
    const chatAppContainer = document.getElementById('chatAppContainer');
    const chatWindow = document.getElementById('chatWindow');
    const userInput = document.getElementById('userInput');
    const chatForm = document.getElementById('chatForm');
    const sendButton = document.getElementById('sendButton');
    const themeToggleButton = document.getElementById('theme-toggle');
    const themeToggleIcon = themeToggleButton.querySelector('.icon');
    const themeToggleText = themeToggleButton.querySelector('.text');
    const personaSelect = document.getElementById('personaSelect');
    const exportChatButton = document.getElementById('exportChatButton');
    const suggestionsContainer = document.getElementById('suggestionsContainer');
    const commandsSuggestionContainer = document.getElementById('commandsSuggestionContainer');
    const micButton = document.getElementById('micButton');
    const threadsSidebar = document.getElementById('threadsSidebar');
    const threadList = document.getElementById('threadList');
    const newThreadButton = document.getElementById('newThreadButton');

    // --- State Variables ---
    let conversationHistory = [];
    let currentChatThreadId = localStorage.getItem('lastActiveThreadId') || 'default_chat';
    let userName = localStorage.getItem('userName') || null;
    let userPreferences = JSON.parse(localStorage.getItem('userPreferences') || '{}');
    let aiTemperature = localStorage.getItem('aiTemperature') || "0.7";
    let initialFocusDone = false;
    const MAX_MESSAGES_DISPLAY = 100;
    const MAX_CONTEXT_MESSAGES = 10;
    let speechRecognition;

    const AVAILABLE_COMMANDS = [
        { cmd: "/help", desc: "Show this help message." },
        { cmd: "/joke", desc: "Tell a joke (client-side)." },
        { cmd: "/temp creative", desc: "Set AI to more creative (temp 0.9)." },
        { cmd: "/temp balanced", desc: "Set AI to balanced (temp 0.7)." },
        { cmd: "/temp precise", desc: "Set AI to more precise (temp 0.3)." },
        { cmd: "/reset", desc: "Reset current chat (clears messages)." },
    ];

    // --- Gemini API Configuration ---
    // #########################################################################
    // ### IMPORTANT: REPLACE WITH YOUR ACTUAL, RESTRICTED GEMINI API KEY ###
    // ###                                                                 ###
    // ### Get your key from Google AI Studio (aistudio.google.com/app/apikey) ###
    // ### RESTRICT IT to your GitHub Pages domain (e.g., your-user.github.io) ###
    // #########################################################################
    const GEMINI_API_KEY = "YOUR_GEMINI_API_KEY"; // <-- FIX 2: REPLACE THIS!

    const MODEL_NAME = "gemini-1.5-flash-latest";

    let genAI;
    let geminiModel;
    let currentGeminiChatSession;

    if (GEMINI_API_KEY && GEMINI_API_KEY !== "YOUR_GEMINI_API_KEY") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModel = genAI.getGenerativeModel({
                model: MODEL_NAME,
                // --- Optional: Adjust Safety Settings ---
                // safetySettings: [
                //   { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                //   { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                //   // Add more categories as needed
                // ],
            });
        } catch (error) {
            console.error("Error initializing Gemini SDK:", error);
            // An error message will be added in initializeChat if geminiModel is not set
        }
    }
    // No 'else' here; initializeChat will handle disabling inputs if key is missing.

    function startNewGeminiChatSession(historyForGemini = []) {
        if (!geminiModel) {
            console.warn("Gemini model not initialized. Cannot start chat session.");
            return null;
        }
        try {
            return geminiModel.startChat({
                history: historyForGemini,
                generationConfig: {
                    temperature: parseFloat(aiTemperature),
                }
            });
        } catch (error) {
            console.error("Error starting new Gemini chat session:", error);
            addMessageToChat("Error starting new AI chat session. Check console.", "bot", false, generateMessageId());
            return null;
        }
    }

    function initializeChat() {
        loadTheme();
        applyViewportHeight();
        loadChatThreads();
        loadConversation(currentChatThreadId);

        // This block correctly disables input if API key is missing.
        // Once you add your key, this 'if' condition will be false, and inputs will remain enabled.
        if (!GEMINI_API_KEY || GEMINI_API_KEY === "YOUR_GEMINI_API_KEY") {
            addMessageToChat("AI functionality disabled: API Key not configured. Please replace 'YOUR_GEMINI_API_KEY' in the script with your restricted key from Google AI Studio.", 'bot', false, generateMessageId());
            sendButton.disabled = true;
            userInput.disabled = true;
        } else if (!geminiModel) { // If key is present but model failed to init
            addMessageToChat("AI functionality disabled: Error initializing AI model. API Key might be invalid or there could be an issue with the Gemini SDK. Check console.", 'bot', false, generateMessageId());
            sendButton.disabled = true;
            userInput.disabled = true;
        } else if (conversationHistory.length === 0 && !document.querySelector('.message.bot[id^="msg"]')) { // Check if greeting already exists more reliably
            const persona = personaSelect.value;
            const greeting = generateGreeting(persona);
            const greetingId = generateMessageId();
            addMessageToChat(greeting, 'bot', false, greetingId);
            updateConversationHistory('assistant', greeting, greetingId); // Ensure history is updated
        }
        // To test UI without using Gemini yet (optional debug bypass):
        // If you uncomment the lines below, remember to comment them back or add your API key.
        // sendButton.disabled = false;
        // userInput.disabled = false;

        displaySuggestedPrompts();
        if (!initialFocusDone) { userInput.focus(); initialFocusDone = true; }
        setTimeout(scrollToBottom, 100);
        updatePersonaSelectBasedOnThread();
    }

    function generateGreeting(persona) {
        const namePart = userName ? ` ${userName}` : '';
        switch(persona) {
            case 'pirate': return `Ahoy Matey${namePart}! What treasures be ye seekin' today? I be yer Gemini-powered pirate!`;
            case 'sarcastic': return `Oh, it's you${namePart}. Back for more, are we? What insightful query plagues your Gemini-powered sarcastic mind now?`;
            case 'friendly': return `Hey there${namePart}! ${userName ? 'So glad to see you again!' : 'Great to meet you!'} I'm your friendly Gemini assistant. What's on your mind?`;
            case 'professional': return `Good day${namePart}. I am your Professional Gemini AI Assistant. How may I be of service?`;
            default: return `${userName ? `Welcome back, ${userName}!` : 'Hello!'} I'm your ${persona} Gemini AI Assistant. How can I help?`;
        }
    }
    function generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    }

    async function fetchAIResponseFromGemini(promptText, currentChatSession, persona, temperature) {
        if (!currentChatSession) {
            console.error("Gemini chat session not initialized for fetch.");
            return "Error: AI chat session not ready. Please reload or check API key.";
        }

        let promptWithPersona = promptText;
        if (persona && persona.toLowerCase() !== "helpful") {
            promptWithPersona = `(System Instruction: Your current persona is ${persona}. Respond accordingly, maintaining this persona throughout your response. Do not explicitly state you are a persona or mention "system instruction" in your actual reply.)\n\nUser: ${promptText}`;
        }

        try {
            const result = await currentChatSession.sendMessageStream(promptWithPersona, {
                generationConfig: { temperature: parseFloat(temperature) }
            });
            return result.stream;
        } catch (error) {
            console.error('Gemini API Error:', error);
            let errorMessage = "Error communicating with Gemini API.";
            if (error.message) errorMessage += ` Details: ${error.message.substring(0,150)}`;
            if (error.toString().includes("API key not valid")) {
                errorMessage = "Error: Invalid Gemini API Key. Please check your key and its restrictions in Google AI Studio.";
            } else if (error.message && (error.message.includes("429") || error.message.toLowerCase().includes("quota"))) {
                 errorMessage = "Error: API Quota exceeded or rate limit hit. Please check your Google Cloud console or try again later.";
            } else if (error.message && error.message.toLowerCase().includes("safety")){
                errorMessage = "Error: The response was blocked due to safety settings. Try rephrasing your prompt.";
            }
            return errorMessage;
        }
    }

    async function handleStreamedResponse(geminiStream, botMessageElement, botMessageId) {
        if (!geminiStream || typeof geminiStream === 'string') {
            const errorMessage = typeof geminiStream === 'string' ? geminiStream : "Error: Unable to stream response (null or invalid stream).";
            botMessageElement.innerHTML = DOMPurify.sanitize(typeof marked !== 'undefined' ? marked.parse(errorMessage) : errorMessage);
            if (typeof Prism !== 'undefined') Prism.highlightAllUnder(botMessageElement);
            updateConversationHistory('assistant', errorMessage, botMessageId);
            enableInputs();
            return;
        }

        let fullText = '';
        userInput.disabled = true;
        sendButton.disabled = true;
        let firstChunk = true;
        const TYPING_DELAY_MS = 5;

        async function appendCharToElement(char) {
            fullText += char;
            botMessageElement.innerHTML = DOMPurify.sanitize(
                (typeof marked !== 'undefined' ? marked.parse(fullText + (firstChunk && fullText.length < 3 ? '‚ñã' : '')) : fullText + (firstChunk && fullText.length < 3 ? '‚ñã' : ''))
            );
            scrollToBottom();
        }

        try {
            for await (const chunk of geminiStream) {
                const textPart = chunk.text ? chunk.text() : (chunk.candidates && chunk.candidates[0]?.content?.parts[0]?.text) || "";
                for (const char of textPart) {
                    await new Promise(resolve => setTimeout(() => {
                        appendCharToElement(char);
                        resolve();
                    }, TYPING_DELAY_MS));
                }
                firstChunk = false;
            }
        } catch (error) {
            console.error('Gemini Streaming error:', error);
            fullText += "\n\n[Error during streaming. The connection might have been interrupted.]";
        } finally {
            botMessageElement.innerHTML = DOMPurify.sanitize(
                (typeof marked !== 'undefined' ? marked.parse(fullText) : fullText)
            );
            if (typeof Prism !== 'undefined') Prism.highlightAllUnder(botMessageElement);
            updateConversationHistory('assistant', fullText, botMessageId);
            saveConversation(currentChatThreadId);
            enableInputs();
            userInput.focus();
        }
    }

    function enableInputs() {
        userInput.disabled = false;
        sendButton.disabled = false;
    }

    function addMessageToChat(text, sender, isLoading = false, messageId) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', sender);
        messageElement.id = messageId;
        messageElement.setAttribute('aria-atomic', 'true');

        if (isLoading) {
            messageElement.classList.add('loading');
            messageElement.innerHTML = `<div class="loading-spinner"></div> <span>Thinking...</span>`;
            messageElement.setAttribute('aria-label', 'Bot is thinking');
        } else {
            if (sender === 'user') {
                messageElement.textContent = text;
            } else {
                const htmlContent = typeof marked !== 'undefined' ? marked.parse(text) : text.replace(/\n/g, '<br>');
                messageElement.innerHTML = DOMPurify.sanitize(htmlContent, { USE_PROFILES: { html: true } });
                if (typeof Prism !== 'undefined') Prism.highlightAllUnder(messageElement);
                addMessageActions(messageElement, text, messageId);
                addInfoTooltipsToMessage(messageElement, text);
            }
        }
        
        chatWindow.appendChild(messageElement);
        pruneOldMessagesDOM();
        scrollToBottom();
        if (!isLoading && sender === 'bot') {
            chatAppContainer.classList.remove('flash');
            void chatAppContainer.offsetWidth;
            chatAppContainer.classList.add('flash');
        }
        return messageElement;
    }

    function addMessageActions(messageElement, originalText, messageId) {
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'message-actions';

        const speakButton = document.createElement('button');
        speakButton.innerHTML = 'üîä';
        speakButton.title = 'Read aloud';
        speakButton.onclick = () => speakText(originalText);
        actionsContainer.appendChild(speakButton);

        const rephraseButton = document.createElement('button');
        rephraseButton.innerHTML = 'üîÅ';
        rephraseButton.title = 'Rephrase this';
        rephraseButton.onclick = () => handleRephraseMessage(originalText, messageId);
        actionsContainer.appendChild(rephraseButton);
        
        messageElement.appendChild(actionsContainer);
    }
    function speakText(text) {
        if (!('speechSynthesis' in window)) {
            alert("Sorry, your browser doesn't support text-to-speech.");
            return;
        }
        const plainText = DOMPurify.sanitize(text, { ALLOWED_TAGS: [] }).replace(/[*_`~#>|]/g, '');
        const utterance = new SpeechSynthesisUtterance(plainText);
        utterance.lang = 'en-US'; 
        speechSynthesis.cancel(); 
        speechSynthesis.speak(utterance);
    }
    function setupSpeechRecognition() {
         if ('webkitSpeechRecognition' in window) {
            speechRecognition = new webkitSpeechRecognition();
            speechRecognition.continuous = false; 
            speechRecognition.interimResults = false;
            speechRecognition.lang = 'en-US';

            speechRecognition.onstart = () => {
                micButton.classList.add('recording');
                micButton.textContent = 'üéôÔ∏è';
                userInput.placeholder = "Listening...";
            };
            speechRecognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                userInput.value = transcript;
            };
            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                userInput.placeholder = "Mic error. Try typing.";
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    alert("Microphone access denied. Please enable it in your browser settings.");
                }
            };
            speechRecognition.onend = () => {
                micButton.classList.remove('recording');
                micButton.textContent = 'üé§';
                userInput.placeholder = "Ask me anything or type /help...";
                if (!userInput.disabled) userInput.focus();
            };
        } else {
            micButton.style.display = 'none'; 
            console.warn("Speech recognition not supported in this browser.");
        }
    }
    micButton.addEventListener('click', () => {
        if (userInput.disabled) return; // Don't allow mic if input is disabled
        if (speechRecognition) {
            try {
                if (micButton.classList.contains('recording')) {
                    speechRecognition.stop();
                } else {
                    speechRecognition.start();
                }
            } catch(e) {
                console.error("Could not start/stop speech recognition: ", e);
                micButton.classList.remove('recording');
                micButton.textContent = 'üé§';
            }
        } else {
            alert("Speech recognition is not available.");
        }
    });
    exportChatButton.addEventListener('click', () => {
        const chatData = {
            threadId: currentChatThreadId,
            persona: personaSelect.value,
            history: conversationHistory,
            exportedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(chatData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `chat_export_${currentChatThreadId}_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    });

    function loadChatThreads() {
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        threadList.innerHTML = ''; 
        if (Object.keys(threads).length === 0) {
            threads['default_chat'] = { name: 'General Chat', lastUpdated: Date.now(), history: [], persona: 'helpful' };
            localStorage.setItem('chatThreads', JSON.stringify(threads));
        }
        currentChatThreadId = localStorage.getItem('lastActiveThreadId') || Object.keys(threads)[0];
        if (!threads[currentChatThreadId]) { 
            currentChatThreadId = Object.keys(threads)[0];
            localStorage.setItem('lastActiveThreadId', currentChatThreadId);
        }
        
        Object.entries(threads).sort(([,a],[,b]) => b.lastUpdated - a.lastUpdated).forEach(([threadId, thread]) => {
            const li = document.createElement('li');
            const button = document.createElement('button');
            button.textContent = thread.name || `Chat ${threadId.substring(0,5)}`;
            button.dataset.threadId = threadId;
            if (threadId === currentChatThreadId) button.classList.add('active');
            button.onclick = () => switchChatThread(threadId);
            li.appendChild(button);
            threadList.appendChild(li);
        });
    }
    function switchChatThread(threadId) {
        saveConversation(currentChatThreadId); 
        currentChatThreadId = threadId;
        localStorage.setItem('lastActiveThreadId', currentChatThreadId);
        loadConversation(threadId);
        document.querySelectorAll('#threadList button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.threadId === threadId);
        });
        updatePersonaSelectBasedOnThread();
    }
    newThreadButton.addEventListener('click', () => {
        const newThreadName = prompt("Enter name for new chat thread:", `Chat Session ${Object.keys(JSON.parse(localStorage.getItem('chatThreads') || '{}')).length + 1}`);
        if (newThreadName) {
            saveConversation(currentChatThreadId); 
            const newThreadId = `thread_${Date.now()}`;
            const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
            threads[newThreadId] = { name: newThreadName, lastUpdated: Date.now(), history: [], persona: personaSelect.value };
            localStorage.setItem('chatThreads', JSON.stringify(threads));
            currentChatThreadId = newThreadId;
            localStorage.setItem('lastActiveThreadId', currentChatThreadId);
            loadChatThreads(); 
            loadConversation(newThreadId); 
            updatePersonaSelectBasedOnThread();
        }
    });
    function updatePersonaSelectBasedOnThread() {
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        const currentThread = threads[currentChatThreadId];
        if (currentThread && currentThread.persona) {
            personaSelect.value = currentThread.persona;
        }
    }
    personaSelect.addEventListener('change', () => {
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        if (threads[currentChatThreadId]) {
            threads[currentChatThreadId].persona = personaSelect.value;
            localStorage.setItem('chatThreads', JSON.stringify(threads));
        }
        const newGreeting = generateGreeting(personaSelect.value);
        const msgId = generateMessageId();
        addMessageToChat(`Switched to ${personaSelect.value} persona. ${newGreeting.split("!")[0]}!`, 'bot', false, msgId);
        updateConversationHistory('assistant', `Switched to ${personaSelect.value} persona.`, msgId);
        
        const formattedHistoryForGemini = conversationHistory
            .filter(msg => msg.role === 'user' || msg.role === 'assistant')
            .slice(-MAX_CONTEXT_MESSAGES * 2)
            .map(msg => ({
                role: msg.role === 'assistant' ? 'model' : 'user',
                parts: [{ text: msg.content }]
            }));
        currentGeminiChatSession = startNewGeminiChatSession(formattedHistoryForGemini);
    });

    function saveConversation(threadId) {
        if (!threadId) return;
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        if (!threads[threadId]) threads[threadId] = { name: `Chat ${threadId.substring(0,5)}`, history: [], persona: personaSelect.value };
        
        // Filter out temporary "Switched to persona..." messages from being saved if they are not desired in long-term history
        const historyToSave = conversationHistory.filter(msg => !msg.content.startsWith("Switched to") || msg.content.includes(generateGreeting(personaSelect.value).split("!")[0]));

        threads[threadId].history = historyToSave;
        threads[threadId].lastUpdated = Date.now();
        threads[threadId].persona = personaSelect.value; 
        localStorage.setItem('chatThreads', JSON.stringify(threads));
    }

    function loadConversation(threadId) {
        if (!threadId) threadId = 'default_chat';
        currentChatThreadId = threadId;
        const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
        const thread = threads[threadId];

        chatWindow.innerHTML = '';
        if (thread && thread.history) {
            conversationHistory = thread.history;
            personaSelect.value = thread.persona || 'helpful';
            conversationHistory.forEach(msg => addMessageToChat(msg.content, msg.role, false, msg.id || generateMessageId()));
        } else {
            conversationHistory = [];
            personaSelect.value = 'helpful';
        }

        const formattedHistoryForGemini = conversationHistory
            .filter(msg => msg.role === 'user' || msg.role === 'assistant')
            .slice(-MAX_CONTEXT_MESSAGES * 2) 
            .map(msg => ({
                role: msg.role === 'assistant' ? 'model' : 'user',
                parts: [{ text: msg.content }]
            }));
        currentGeminiChatSession = startNewGeminiChatSession(formattedHistoryForGemini);
        scrollToBottom();
    }

    function displaySuggestedPrompts() {
        const suggestions = [
            "Tell me a fun fact.", "Explain quantum computing simply.", 
            "What's the weather like in Paris?", "Draft an email to my boss.",
            "Suggest a recipe for dinner."
        ];
        suggestionsContainer.innerHTML = ''; 
        suggestions.forEach(text => {
            const btn = document.createElement('button');
            btn.textContent = text;
            btn.onclick = () => {
                userInput.value = text;
                handleSendMessage();
                suggestionsContainer.style.display = 'none'; 
            };
            suggestionsContainer.appendChild(btn);
        });
    }
    userInput.addEventListener('focus', () => {
        if(conversationHistory.length <= 1 && userInput.value === '' && !userInput.disabled) suggestionsContainer.style.display = 'flex'; 
        commandsSuggestionContainer.style.display = 'none';
    });
    userInput.addEventListener('blur', () => {
        setTimeout(() => {
            if (!commandsSuggestionContainer.contains(document.activeElement)) { 
                 commandsSuggestionContainer.style.display = 'none';
            }
            if (!suggestionsContainer.contains(document.activeElement)) {
                 suggestionsContainer.style.display = 'none';
            }
        }, 150);
    });
    userInput.addEventListener('input', () => {
        const text = userInput.value;
        if (text.startsWith('/') && text.length >=1 && !userInput.disabled) {
            const searchTerm = text.substring(1).toLowerCase();
            const filteredCommands = AVAILABLE_COMMANDS.filter(cmdObj => cmdObj.cmd.substring(1).startsWith(searchTerm));
            displayCommandSuggestions(filteredCommands);
            suggestionsContainer.style.display = 'none';
        } else {
            commandsSuggestionContainer.style.display = 'none';
            if (conversationHistory.length <= 1 && text === '' && !userInput.disabled) {
                suggestionsContainer.style.display = 'flex';
            } else {
                suggestionsContainer.style.display = 'none';
            }
        }
    });
    function displayCommandSuggestions(commands) {
        commandsSuggestionContainer.innerHTML = '';
        if (commands.length > 0) {
            commands.forEach(cmdObj => {
                const btn = document.createElement('button');
                btn.textContent = `${cmdObj.cmd} - ${cmdObj.desc}`;
                btn.onclick = () => {
                    userInput.value = cmdObj.cmd + (cmdObj.cmd.includes('<') ? ' ' : ''); 
                    commandsSuggestionContainer.style.display = 'none';
                    if (!userInput.disabled) userInput.focus();
                    if (!cmdObj.cmd.includes('<')) { 
                        handleSendMessage();
                    }
                };
                commandsSuggestionContainer.appendChild(btn);
            });
            commandsSuggestionContainer.style.display = 'flex';
        } else {
            commandsSuggestionContainer.style.display = 'none';
        }
    }
    function detectEmotion(text) {
        const lowerText = text.toLowerCase();
        if (/\b(angry|furious|pissed off|annoyed|frustrated|hate)\b/i.test(lowerText)) return "angry";
        if (/\b(sad|upset|crying|depressed|miserable)\b/i.test(lowerText)) return "sad";
        if (/\b(happy|excited|yay|great|awesome|love it)\b/i.test(lowerText)) return "happy";
        if (/\b(confused|huh|what\?|don't understand)\b/i.test(lowerText)) return "confused";
        return "neutral";
    }
    function handleEmotionalResponse(emotion, userMessage) {
        console.log(`User emotion detected: ${emotion} for message: "${userMessage}"`);
    }
    function addInfoTooltipsToMessage(messageElement, text) {
        const knownFacts = { 
            "Paris": "The capital city of France, known for the Eiffel Tower.", 
            "GPT-4": "A large language model developed by OpenAI.",
            "Gemini AI": "A family of multimodal AI models by Google.",
            "Quantum Computing": "A type of computation that harnesses quantum phenomena like superposition and entanglement."
        };
        let html = messageElement.innerHTML;
        for (const fact in knownFacts) {
            if (text.toLowerCase().includes(fact.toLowerCase())) { 
                const regex = new RegExp(`\\b(${fact})\\b`, 'gi'); 
                html = html.replace(regex, (match) => `${match} <span class="info-tooltip" title="${knownFacts[fact]}">‚ÑπÔ∏è</span>`);
            }
        }
        messageElement.innerHTML = html;
    }
    async function handleRephraseMessage(originalText, originalMessageId) {
        const userPrompt = `(System Instruction: Your task is to rephrase the following text clearly and concisely, perhaps offering a slightly different perspective or wording, without adding new information. Do not include preambles like "Certainly, here's a rephrased version:" Just provide the rephrased text directly.)\n\nRephrase this: "${originalText}"`;
        const tempUserMsgId = generateMessageId();
        addMessageToChat(`(Attempting to rephrase...)`, 'user', false, tempUserMsgId);
        
        const loadingIndicator = addMessageToChat('', 'bot', true, generateMessageId());
        sendButton.disabled = true;
        userInput.disabled = true;

        let tempRephraseChat = null;
        if (geminiModel) {
             tempRephraseChat = geminiModel.startChat({ history: [], generationConfig: { temperature: 0.5 } });
        } else {
            addMessageToChat("Rephrase feature unavailable: AI model not initialized.", "bot", false, generateMessageId());
            loadingIndicator.remove();
            document.getElementById(tempUserMsgId)?.remove();
            enableInputs();
            return;
        }

        const geminiStream = await fetchAIResponseFromGemini(userPrompt, tempRephraseChat, "helpful", "0.5");
        loadingIndicator.remove();
        document.getElementById(tempUserMsgId)?.remove();

        if (typeof geminiStream === 'string') {
            const errId = generateMessageId();
            addMessageToChat(geminiStream, 'bot', false, errId);
            updateConversationHistory('assistant', geminiStream, errId);
            enableInputs();
            return;
        }

        const rephraseMsgId = generateMessageId();
        const rephrasedBotMsgElement = addMessageToChat('', 'bot', false, rephraseMsgId);
        rephrasedBotMsgElement.innerHTML = '‚ñã';

        let rephrasedTextFull = '';
        try {
            for await (const chunk of geminiStream) {
                const textPart = chunk.text ? chunk.text() : (chunk.candidates && chunk.candidates[0]?.content?.parts[0]?.text) || "";
                rephrasedTextFull += textPart;
                rephrasedBotMsgElement.innerHTML = DOMPurify.sanitize(typeof marked !== 'undefined' ? marked.parse(rephrasedTextFull + '‚ñã') : rephrasedTextFull + '‚ñã');
                scrollToBottom();
            }
        } catch (e) {
            rephrasedTextFull += "\n[Error during rephrase streaming]";
        } finally {
            rephrasedBotMsgElement.innerHTML = DOMPurify.sanitize(typeof marked !== 'undefined' ? marked.parse(rephrasedTextFull) : rephrasedTextFull);
            if (typeof Prism !== 'undefined') Prism.highlightAllUnder(rephrasedBotMsgElement);
            
            const originalMsgElement = document.getElementById(originalMessageId);
            if (originalMsgElement && !rephrasedTextFull.toLowerCase().startsWith("error:")) {
                originalMsgElement.innerHTML = DOMPurify.sanitize(typeof marked !== 'undefined' ? marked.parse(`(Original): ${originalText}<hr>(Rephrased): ${rephrasedTextFull}`) : `(Original): ${originalText}<hr>(Rephrased): ${rephrasedTextFull}`);
                if (typeof Prism !== 'undefined') Prism.highlightAllUnder(originalMsgElement);
                const msgIndex = conversationHistory.findIndex(msg => msg.id === originalMessageId);
                if (msgIndex !== -1) {
                    conversationHistory[msgIndex].content = `(Original): ${originalText}\n(Rephrased): ${rephrasedTextFull}`;
                     saveConversation(currentChatThreadId); // Save change to original message
                }
            } else { 
                 updateConversationHistory('assistant', `(Rephrased): ${rephrasedTextFull}`, rephraseMsgId);
                 saveConversation(currentChatThreadId); // Save new rephrased message
            }
            enableInputs();
        }
    }
    function extractAndStoreUserPreferences(promptText) {
        const lowerPrompt = promptText.toLowerCase();
        let nameFound = null;
        if (lowerPrompt.includes("my name is ")) {
            nameFound = lowerPrompt.split("my name is ")[1].split(/[\s,.!?]/)[0];
        } else if (lowerPrompt.includes("call me ")) {
            nameFound = lowerPrompt.split("call me ")[1].split(/[\s,.!?]/)[0];
        }
        if (nameFound && nameFound.length > 1 && nameFound.length < 20) {
            userName = nameFound.charAt(0).toUpperCase() + nameFound.slice(1);
            localStorage.setItem('userName', userName); 
            console.log("Username stored:", userName);
            const msgId = generateMessageId();
            addMessageToChat(`Got it, I'll call you ${userName}!`, 'bot', false, msgId);
            updateConversationHistory('assistant',`Got it, I'll call you ${userName}!`, msgId);
        }

        const colorMatch = lowerPrompt.match(/my favorite colou?r is (\w+)/);
        if (colorMatch && colorMatch[1]) {
            userPreferences.favoriteColor = colorMatch[1];
            localStorage.setItem('userPreferences', JSON.stringify(userPreferences));
            const msgId = generateMessageId();
            addMessageToChat(`Nice! ${userPreferences.favoriteColor.charAt(0).toUpperCase() + userPreferences.favoriteColor.slice(1)} is a great color. I'll remember that.`, 'bot', false, msgId);
            updateConversationHistory('assistant', `Nice! ${userPreferences.favoriteColor.charAt(0).toUpperCase() + userPreferences.favoriteColor.slice(1)} is a great color. I'll remember that.`, msgId);
        }
    }
    function suggestPersonaChange(messageText) {
         const lowerText = messageText.toLowerCase();
        let newPersona = null;
        if (lowerText.includes("make it funny") || lowerText.includes("tell me a joke") || lowerText.includes("be sarcastic")) {
            newPersona = "sarcastic";
        } else if (lowerText.includes("be serious") || lowerText.includes("formal response") || lowerText.includes("professional")) {
            newPersona = "professional";
        }

        if (newPersona && personaSelect.value !== newPersona) {
            const suggestionId = generateMessageId();
            const suggestionMsg = addMessageToChat(`I can switch to my ${newPersona} persona for that if you'd like. <button data-persona="${newPersona}" class="persona-suggestion-btn" style="padding: 3px 6px; margin-left: 5px; cursor: pointer; border-radius: 5px; border: 1px solid var(--button-bg); background: var(--suggestion-bg); color: var(--suggestion-text);">Switch to ${newPersona}</button>`, 'bot', false, suggestionId);
            
            const btn = suggestionMsg.querySelector('.persona-suggestion-btn');
            if (btn) {
                btn.onclick = (e) => {
                    personaSelect.value = e.target.dataset.persona;
                    personaSelect.dispatchEvent(new Event('change'));
                    e.target.closest('.message').remove();
                    const historyIndex = conversationHistory.findIndex(msg => msg.id === suggestionId);
                    if(historyIndex > -1) conversationHistory.splice(historyIndex, 1);
                };
            }
        }
    }
    function updateConversationHistory(role, content, id, replace = false) {
        if (replace) {
            const existingMsgIndex = conversationHistory.findIndex(msg => msg.id === id);
            if (existingMsgIndex !== -1) {
                conversationHistory[existingMsgIndex] = { role, content, id };
                return;
            }
        }
        if (conversationHistory.some(msg => msg.id === id)) return; // Avoid duplicates if already added
        conversationHistory.push({ role, content, id });
    }
    async function handleCommand(commandText) {
        const [command, ...args] = commandText.substring(1).toLowerCase().split(' ');
        let commandProcessed = true;
        let botResponse = "";

        switch(command) {
            case 'help':
                botResponse = "Available commands:\n" + AVAILABLE_COMMANDS.map(c => `${c.cmd} - ${c.desc}`).join('\n');
                break;
            case 'joke':
                const jokes = [
                    "Why don't scientists trust atoms? Because they make up everything!",
                    "Why did the scarecrow win an award? Because he was outstanding in his field!",
                ];
                botResponse = jokes[Math.floor(Math.random() * jokes.length)];
                break;
            case 'temp':
                if (args.length > 0) {
                    const tempArg = args[0];
                    if (tempArg === 'creative') aiTemperature = "0.9";
                    else if (tempArg === 'balanced') aiTemperature = "0.7";
                    else if (tempArg === 'precise') aiTemperature = "0.3";
                    else { botResponse = "Usage: /temp [creative|balanced|precise]"; break; }
                    localStorage.setItem('aiTemperature', aiTemperature);
                    botResponse = `AI temperature set to ${tempArg} (value: ${aiTemperature}).`;
                } else {
                    botResponse = `Current AI temperature is ${aiTemperature}. Use /temp [creative|balanced|precise] to change.`;
                }
                break;
            case 'reset':
                chatWindow.innerHTML = '';
                conversationHistory = [];
                const currentPersonaForReset = personaSelect.value;
                const greetingForReset = generateGreeting(currentPersonaForReset);
                const greetingIdForReset = generateMessageId();
                addMessageToChat(greetingForReset, 'bot', false, greetingIdForReset);
                updateConversationHistory('assistant', greetingForReset, greetingIdForReset);
                currentGeminiChatSession = startNewGeminiChatSession();
                saveConversation(currentChatThreadId);
                break; // No botResponse needed as chat is cleared.
            default:
                commandProcessed = false; 
        }

        if (commandProcessed && botResponse) {
            const botMessageId = generateMessageId();
            addMessageToChat(botResponse, 'bot', false, botMessageId);
            updateConversationHistory('assistant', botResponse, botMessageId);
        }
        return commandProcessed;
    }

    async function handleSendMessage(event) {
        if (event) event.preventDefault();
        const messageText = userInput.value.trim();
        if (messageText === '') return;

        const userMessageId = generateMessageId(); // Generate ID before clearing input
        addMessageToChat(messageText, 'user', false, userMessageId); // Add user message to UI first
        updateConversationHistory('user', messageText, userMessageId); // Then update history

        userInput.value = ''; 
        suggestionsContainer.style.display = 'none';
        commandsSuggestionContainer.style.display = 'none';

        extractAndStoreUserPreferences(messageText);
        suggestPersonaChange(messageText);
        const userEmotion = detectEmotion(messageText);
        handleEmotionalResponse(userEmotion, messageText);

        if (messageText.startsWith('/')) {
            const commandProcessed = await handleCommand(messageText);
            if (commandProcessed) {
                scrollToBottom();
                if (!userInput.disabled) userInput.focus();
                return;
            }
        }
        
        if (!geminiModel || !currentGeminiChatSession) {
            addMessageToChat("AI is not available. Please check API Key or reload.", "bot", false, generateMessageId());
            enableInputs();
            return;
        }

        const currentPersona = personaSelect.value;
        const loadingIndicator = addMessageToChat('', 'bot', true, generateMessageId());
        sendButton.disabled = true;
        userInput.disabled = true;

        const geminiStream = await fetchAIResponseFromGemini(messageText, currentGeminiChatSession, currentPersona, aiTemperature);
        loadingIndicator.remove();

        if (typeof geminiStream === 'string') {
            const botMessageId = generateMessageId();
            addMessageToChat(geminiStream, 'bot', false, botMessageId);
            updateConversationHistory('assistant', geminiStream, botMessageId); // Also save errors to history
            enableInputs();
             saveConversation(currentChatThreadId); // Save conversation even if there's an error from AI
        } else { 
            const botMessageId = generateMessageId();
            const botMessageElement = addMessageToChat('', 'bot', false, botMessageId);
            botMessageElement.innerHTML = '‚ñã';
            await handleStreamedResponse(geminiStream, botMessageElement, botMessageId);
            // History, saving, and inputs re-enabled within handleStreamedResponse
        }
    }

    function scrollToBottom() {
        if(chatWindow) setTimeout(() => { chatWindow.scrollTop = chatWindow.scrollHeight; },0);
    }
    function pruneOldMessagesDOM() {
        while (chatWindow.children.length > MAX_MESSAGES_DISPLAY) {
            chatWindow.removeChild(chatWindow.firstChild);
        }
    }
    function applyViewportHeight() {
        const setHeight = () => {
            if(document.querySelector('.chat-area')) {
                 document.querySelector('.chat-area').style.height = window.innerHeight + 'px';
            }
        };
        setHeight();
        window.addEventListener('resize', setHeight);
    }
    function loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        document.body.classList.toggle('dark-mode', savedTheme === 'dark');
        updateThemePreference();
    }
    function updateThemePreference() {
        const isDarkMode = document.body.classList.contains('dark-mode');
        if (themeToggleIcon) themeToggleIcon.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
        if (themeToggleText) themeToggleText.textContent = isDarkMode ? 'Light' : 'Dark';
        localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
    }

    chatForm.addEventListener('submit', handleSendMessage);
    themeToggleButton.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        updateThemePreference();
    });

    initializeChat();
    setupSpeechRecognition();

});
</script>
</body>
</html>
