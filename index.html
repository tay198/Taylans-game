<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>AI ChatBot by Taylan - Advanced</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" data-manual></script>
    <style>
        :root {
            --body-bg-light: #f4f6f8; --body-bg-dark: #0d1117;
            --chat-bg-light: #ffffff; --chat-bg-dark: #161b22;
            --header-bg-light: #007bff; --header-bg-dark: #1f6feb;
            --header-text-light: #ffffff; --header-text-dark: #c9d1d9;
            --user-msg-bg-light: #007bff; --user-msg-bg-dark: #1f6feb;
            --user-msg-text-light: #ffffff; --user-msg-text-dark: #e0e0e0;
            --bot-msg-bg-light: #e9ecef; --bot-msg-bg-dark: #21262d;
            --bot-msg-text-light: #333333; --bot-msg-text-dark: #c9d1d9;
            --input-bg-light: #ffffff; --input-bg-dark: #0d1117;
            --input-text-light: #333333; --input-text-dark: #c9d1d9;
            --input-border-light: #ced4da; --input-border-dark: #30363d;
            --button-bg-light: #007bff; --button-bg-dark: #238636;
            --button-text-light: #ffffff; --button-text-dark: #ffffff;
            --text-color-light: #212529; --text-color-dark: #c9d1d9;
            --border-color-light: #dee2e6; --border-color-dark: #30363d;
            --shadow-light: 0 2px 10px rgba(0,0,0,0.075); --shadow-dark: 0 3px 12px rgba(0,0,0,0.25);
            --focus-ring-light: rgba(0,123,255,0.25); --focus-ring-dark: rgba(31,111,235,0.4);
            --suggestion-bg-light: #e0e0e0; --suggestion-bg-dark: #2a2a2a;
            --suggestion-text-light: #333; --suggestion-text-dark: #ccc;

            --body-bg: var(--body-bg-light); --chat-bg: var(--chat-bg-light);
            --header-bg: var(--header-bg-light); --header-text: var(--header-text-light);
            --user-msg-bg: var(--user-msg-bg-light); --user-msg-text: var(--user-msg-text-light);
            --bot-msg-bg: var(--bot-msg-bg-light); --bot-msg-text: var(--bot-msg-text-light);
            --input-bg: var(--input-bg-light); --input-text: var(--input-text-light);
            --input-border: var(--input-border-light); --button-bg: var(--button-bg-light);
            --button-text: var(--button-text-light); --text-color: var(--text-color-light);
            --border-color: var(--border-color-light); --shadow: var(--shadow-light);
            --focus-ring: var(--focus-ring-light);
            --suggestion-bg: var(--suggestion-bg-light); --suggestion-text: var(--suggestion-text-light);
        }
        body.dark-mode {
            --body-bg: var(--body-bg-dark); --chat-bg: var(--chat-bg-dark);
            --header-bg: var(--header-bg-dark); --header-text: var(--header-text-dark);
            --user-msg-bg: var(--user-msg-bg-dark); --user-msg-text: var(--user-msg-text-dark);
            --bot-msg-bg: var(--bot-msg-bg-dark); --bot-msg-text: var(--bot-msg-text-dark);
            --input-bg: var(--input-bg-dark); --input-text: var(--input-text-dark);
            --input-border: var(--input-border-dark); --button-bg: var(--button-bg-dark);
            --button-text: var(--button-text-dark); --text-color: var(--text-color-dark);
            --border-color: var(--border-color-dark); --shadow: var(--shadow-dark);
            --focus-ring: var(--focus-ring-dark);
            --suggestion-bg: var(--suggestion-bg-dark); --suggestion-text: var(--suggestion-text-dark);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        html { height: 100%; }
        body {
            background-color: var(--body-bg); color: var(--text-color);
            display: flex; flex-direction: row; /* For sidebar + chat container */
            min-height: 100%; transition: background-color 0.3s, color 0.3s;
        }

        /* Placeholder for Chat Threads Sidebar */
        .threads-sidebar {
            width: 250px;
            background-color: var(--chat-bg);
            border-right: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, border-color 0.3s;
            /* Initially hidden on small screens, can be toggled */
            display: none; 
        }
        .threads-sidebar h3 { margin-bottom: 10px; font-size: 1.1em; color: var(--text-color); }
        .threads-sidebar ul { list-style: none; }
        .threads-sidebar li button { /* Style for thread items */
            width: 100%; text-align: left; padding: 8px; margin-bottom: 5px;
            background: none; border: 1px solid transparent; color: var(--text-color);
            border-radius: 5px; cursor: pointer;
        }
        .threads-sidebar li button:hover, .threads-sidebar li button.active {
            background-color: var(--bot-msg-bg); border-color: var(--button-bg);
        }
        #newThreadButton { margin-top: auto; padding: 10px; }


        .chat-area { /* Renamed from chat-container to distinguish from sidebar */
            flex-grow: 1; /* Takes remaining space */
            display: flex; flex-direction: column;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Dynamic viewport height */
        }

        .chat-container { /* This is now the main chat view within chat-area */
            width: 100%;
            max-width: 100%; /* Max width within .chat-area */
            flex-grow: 1; /* Takes up space within chat-area */
            background-color: var(--chat-bg);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s;
        }
        .chat-container.flash { animation: subtleBackgroundFlash 0.5s ease-out forwards; }
        @keyframes subtleBackgroundFlash {
            0% { background-color: var(--chat-bg); }
            25% { background-color: color-mix(in srgb, var(--chat-bg) 95%, var(--button-bg) 5%); }
            100% { background-color: var(--chat-bg); }
        }

        .chat-header {
            padding: 10px 15px; background-color: var(--header-bg); color: var(--header-text);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color); transition: all 0.3s; flex-shrink: 0;
        }
        .chat-header h2 { font-size: 1.1em; margin: 0; display: flex; flex-direction: column; align-items: flex-start; }
        .chat-header h2 .title-main { line-height: 1; }
        .chat-header h2 .title-subtitle { font-size: 0.65em; font-weight: normal; opacity: 0.85; margin-top: 2px; line-height: 1; }
        
        .header-controls { display: flex; align-items: center; gap: 10px; }
        .header-controls label { font-size: 0.8em; }
        .header-controls select, .header-controls button {
            padding: 5px 8px; border-radius: 5px; border: 1px solid var(--header-text);
            background-color: var(--header-bg); color: var(--header-text); font-size: 0.8em;
        }
        .header-controls button:hover { background-color: var(--header-text); color: var(--header-bg); }


        .chat-window {
            flex-grow: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px;
            scrollbar-width: thin; scrollbar-color: var(--button-bg) var(--chat-bg);
        }
        .chat-window::-webkit-scrollbar { width: 8px; }
        .chat-window::-webkit-scrollbar-track { background: var(--chat-bg); }
        .chat-window::-webkit-scrollbar-thumb { background-color: var(--button-bg); border-radius: 10px; border: 2px solid var(--chat-bg); }

        .message {
            padding: 10px 15px; border-radius: 18px; max-width: 80%; line-height: 1.5;
            opacity: 0; transform: translateY(10px); animation: fadeInMessage 0.4s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
            word-wrap: break-word; position: relative; /* For action buttons */
        }
        @keyframes fadeInMessage { 0% { opacity: 0; transform: translateY(15px) scale(0.95); } 100% { opacity: 1; transform: translateY(0) scale(1); } }
        .message.fade-out { animation: fadeOutMessage 0.3s ease forwards; }
        @keyframes fadeOutMessage { to { opacity: 0; transform: translateY(-5px); height: 0; padding:0; margin:0; border:0; } }

        .message.user { background-color: var(--user-msg-bg); color: var(--user-msg-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .message.bot { background-color: var(--bot-msg-bg); color: var(--bot-msg-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        
        .message-actions { /* Container for buttons next to messages */
            position: absolute; bottom: -5px; right: -5px; display: none; gap: 3px;
            background-color: var(--chat-bg); padding:3px; border-radius: 5px; box-shadow: var(--shadow);
        }
        .message:hover .message-actions { display: flex; }
        .message-actions button { background: none; border: none; cursor: pointer; font-size: 0.9em; padding: 3px; }
        .message-actions button:hover { opacity: 0.7; }


        .message.bot.typing .dot { display:inline-block; width:9px; height:9px; border-radius:50%; background:currentColor; animation:bounceTyping 1.3s infinite ease-in-out; margin:0 2.5px; }
        .message.bot.typing .dot:nth-child(1){animation-delay:0s;} .message.bot.typing .dot:nth-child(2){animation-delay:.15s;} .message.bot.typing .dot:nth-child(3){animation-delay:.3s;}
        @keyframes bounceTyping { 0%,70%,100%{transform:translateY(0) scale(.6);opacity:.6} 35%{transform:translateY(-4px) scale(1);opacity:1} }

        .suggestions-container {
            padding: 5px 15px 10px; display: flex; flex-wrap: wrap; gap: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .suggestions-container button {
            padding: 6px 10px; border-radius: 15px; border: 1px solid var(--input-border);
            background-color: var(--suggestion-bg); color: var(--suggestion-text);
            font-size: 0.85em; cursor: pointer; transition: background-color 0.2s;
        }
        .suggestions-container button:hover { opacity: 0.8; }

        .chat-input-form {
            display: flex; padding: 10px 15px; border-top: 1px solid var(--border-color);
            background-color: var(--chat-bg); transition: all 0.3s; flex-shrink: 0; align-items: center;
        }
        #micButton {
            padding: 8px 10px; margin-right: 8px; border-radius: 50%;
            background-color: transparent; border: 1px solid var(--input-border);
            color: var(--text-color); cursor: pointer; font-size: 1.1em;
        }
        #micButton:hover { background-color: var(--bot-msg-bg); }
        #micButton.recording { background-color: #ff4d4dcc; color: white; }


        #userInput {
            flex-grow: 1; padding: 10px 15px; border: 1px solid var(--input-border); border-radius: 20px;
            font-size: 1em; background-color: var(--input-bg); color: var(--input-text); transition: all 0.3s;
            margin-right: 8px;
        }
        #userInput:focus, #sendButton:focus, #theme-toggle:focus, #micButton:focus {
            outline: none; border-color: var(--button-bg); box-shadow: 0 0 0 3px var(--focus-ring);
        }
        #sendButton {
            padding: 10px 18px; background-color: var(--button-bg); color: var(--button-text);
            border: none; border-radius: 20px; cursor: pointer; font-size: 1em; font-weight: bold; transition: all 0.2s;
        }
        #sendButton:hover:not(:disabled) { opacity:0.85; }
        #sendButton:disabled { background-color:color-mix(in srgb,var(--button-bg) 40%,#88888890); cursor:not-allowed; opacity:.6; }

        /* For Markdown content - general styling */
        .message pre { white-space: pre-wrap; background-color: #2d2d2d; color: #f0f0f0; padding: 10px; border-radius: 5px; margin: 5px 0; overflow-x: auto;}
        .message code { font-family: 'Courier New', Courier, monospace; }
        .message blockquote { border-left: 3px solid #ccc; padding-left: 10px; margin-left: 5px; color: #888; }
        .dark-mode .message pre { background-color: #1e1e1e; border: 1px solid #333; }
        .dark-mode .message code { /* Prism will handle its own dark theme mostly */ }
        .dark-mode .message blockquote { border-left-color: #555; color: #aaa; }

        .info-tooltip {
            display: inline-block;
            width: 14px; height: 14px;
            border-radius: 50%;
            background-color: var(--button-bg); color: var(--button-text);
            text-align: center; font-size: 10px; line-height: 14px;
            margin-left: 4px; cursor: help; user-select: none;
        }


        /* Responsive: Show sidebar on wider screens */
        @media (min-width: 769px) {
            .threads-sidebar { display: flex; }
        }
        @media (max-width: 800px) { /* Mobile adjustments */
             .chat-area { border-radius: 0; margin: 0; }
        }
    </style>
</head>
<body>
    <aside class="threads-sidebar" id="threadsSidebar">
        <h3>Chat Threads</h3>
        <ul id="threadList">
            </ul>
        <button id="newThreadButton" class="header-controls button">New Chat</button>
    </aside>

    <main class="chat-area">
        <div class="chat-container" id="chatAppContainer">
            <header class="chat-header">
                <h2>
                    <span class="title-main">AI Assistant</span>
                    <span class="title-subtitle">by Taylan</span>
                </h2>
                <div class="header-controls">
                    <label for="personaSelect">Persona:</label>
                    <select id="personaSelect">
                        <option value="helpful">Helpful Assistant</option>
                        <option value="friendly">Friendly Pal</option>
                        <option value="professional">Professional Expert</option>
                        <option value="sarcastic">Sarcastic Wit</option>
                        <option value="pirate">Pirate Captain</option>
                    </select>
                    <button id="exportChatButton" aria-label="Export chat">Export</button>
                    <button id="theme-toggle" aria-label="Toggle color theme">
                        <span class="icon"></span> <span class="text">Theme</span>
                    </button>
                </div>
            </header>

            <div class="suggestions-container" id="suggestionsContainer">
                </div>

            <div class="chat-window" id="chatWindow" role="log" aria-live="polite"></div>

            <form class="chat-input-form" id="chatForm">
                <button type="button" id="micButton" aria-label="Use microphone">🎤</button>
                <input type="text" id="userInput" placeholder="Ask me anything..." autocomplete="off" aria-label="User message input" role="textbox">
                <button type="submit" id="sendButton" aria-label="Send message">Send</button>
            </form>
        </div>
    </main>

    <script defer>
    document.addEventListener('DOMContentLoaded', () => {
        const chatAppContainer = document.getElementById('chatAppContainer');
        const chatWindow = document.getElementById('chatWindow');
        const userInput = document.getElementById('userInput');
        const chatForm = document.getElementById('chatForm');
        const sendButton = document.getElementById('sendButton');
        const themeToggleButton = document.getElementById('theme-toggle');
        const themeToggleIcon = themeToggleButton.querySelector('.icon');
        const themeToggleText = themeToggleButton.querySelector('.text');
        const personaSelect = document.getElementById('personaSelect');
        const exportChatButton = document.getElementById('exportChatButton');
        const suggestionsContainer = document.getElementById('suggestionsContainer');
        const micButton = document.getElementById('micButton');
        const threadsSidebar = document.getElementById('threadsSidebar');
        const threadList = document.getElementById('threadList');
        const newThreadButton = document.getElementById('newThreadButton');


        let conversationHistory = []; // For Feature 2: Multi-Turn Context
        let currentChatThreadId = 'default_chat'; // For Feature 8: Persistent Chat Threads
        let userName = localStorage.getItem('userName') || null;
        let aiTemperature = localStorage.getItem('aiTemperature') || "balanced"; // For /temp command
        let initialFocusDone = false;
        const MAX_MESSAGES_DISPLAY = 100; // Max messages to keep in DOM for performance
        let speechRecognition; // For Feature 5: Voice Input

        // --- CORE FUNCTIONS ---
        function initializeChat() {
            loadTheme();
            applyViewportHeight();
            loadChatThreads(); // Feature 8
            loadConversation(currentChatThreadId); // Load default/last active thread
            displaySuggestedPrompts(); // Feature 11
            
            if (!conversationHistory.length) { // Only greet if no history loaded
                const persona = personaSelect.value;
                const greeting = generateGreeting(persona);
                addMessageToChat(greeting, 'bot', false, generateMessageId());
                conversationHistory.push({ role: 'assistant', content: greeting, id: generateMessageId() });
            }
            
            if (!initialFocusDone) { userInput.focus(); initialFocusDone = true; }
            setTimeout(scrollToBottom, 100);
        }

        function generateGreeting(persona) {
            switch(persona) {
                case 'pirate': return "Ahoy Matey! What treasures be ye seekin' today?";
                case 'sarcastic': return "Oh, look who decided to show up. What do you want?";
                case 'friendly': return `Hey there, friend! ${userName ? `Welcome back, ${userName}!` : ''} What's on your mind?`;
                default: return `${userName ? `Welcome back, ${userName}!` : 'Hello!'} I'm your ${persona} AI Assistant. How can I help?`;
            }
        }
        
        function generateMessageId() { return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`; }

        // --- FEATURE 1 & 2: Real AI API Integration & Context Memory ---
        // This function now calls YOUR backend API.
        async function fetchAIResponseFromServer(promptText, history, persona, stream = false) {
            const endpoint = stream ? '/api/chat-stream' : '/api/chat';
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: promptText, 
                        history: history,
                        persona: persona, // Feature 6
                        // You can add other parameters like temperature, max_tokens etc.
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: "Unknown error occurred" }));
                    console.error('API Error:', response.status, errorData);
                    return `Error: ${errorData.detail || response.statusText}. (Is your backend server running?)`;
                }
                
                if (stream) { // Feature 3: Streaming Response
                    return response.body.getReader(); // Return reader for streaming
                } else {
                    const data = await response.json();
                    return data.reply || "Sorry, I couldn't get a response from the AI.";
                }
            } catch (error) {
                console.error('Network or Fetch Error:', error);
                return "Network error. Could not reach the AI service. (Is your backend server running and configured?)";
            }
        }

        // --- FEATURE 3: Streaming Response (Client-side handling) ---
        async function handleStreamedResponse(reader, botMessageElement, botMessageId) {
            const decoder = new TextDecoder();
            let fullText = '';
            userInput.disabled = true; // Keep disabled during stream
            sendButton.disabled = true;

            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    fullText += chunk;
                    // Sanitize and parse Markdown incrementally if possible, or at the end
                    botMessageElement.innerHTML = marked.parse(sanitizeHTML(fullText + '▋')); // Use a cursor char
                    scrollToBottom();
                }
            } catch (error) {
                console.error('Streaming error:', error);
                botMessageElement.innerHTML = marked.parse(sanitizeHTML(fullText + "\n\n[Error during streaming]"));
            } finally {
                botMessageElement.innerHTML = marked.parse(sanitizeHTML(fullText)); // Final render
                Prism.highlightAllUnder(botMessageElement); // Feature 10
                updateConversationHistory('assistant', fullText, botMessageId);
                saveConversation(currentChatThreadId);
                userInput.disabled = false;
                sendButton.disabled = false;
                userInput.focus();
            }
        }


        function sanitizeHTML(text) { /* ... (same as before) ... */ 
            const temp = document.createElement('div');
            temp.textContent = text;
            return temp.innerHTML; // Simplistic, for demo. Use DOMPurify for production.
        }

        function addMessageToChat(text, sender, isTyping = false, messageId) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', sender);
            messageElement.id = messageId;
            messageElement.setAttribute('aria-atomic', 'true');

            if (isTyping) {
                messageElement.classList.add('typing');
                messageElement.innerHTML = `<span class="dot"></span><span class="dot"></span><span class="dot"></span>`;
                messageElement.setAttribute('aria-label', 'Bot is typing');
            } else {
                if (sender === 'user') {
                    messageElement.textContent = text;
                } else { // Bot message with Markdown
                    const partiallySanitizedHTML = sanitizeHTML(text); // Basic sanitization first
                    messageElement.innerHTML = marked.parse(partiallySanitizedHTML); // Feature 9
                    Prism.highlightAllUnder(messageElement); // Feature 10
                    addMessageActions(messageElement, text, messageId); // Add Speak, Rephrase buttons
                    addInfoTooltipsToMessage(messageElement, text); // Feature 13
                }
            }
            
            chatWindow.appendChild(messageElement);
            pruneOldMessagesDOM();
            scrollToBottom();
            if (!isTyping && sender === 'bot') {
                chatAppContainer.classList.remove('flash');
                void chatAppContainer.offsetWidth;
                chatAppContainer.classList.add('flash');
            }
            return messageElement;
        }

        function addMessageActions(messageElement, originalText, messageId) {
            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'message-actions';

            // Feature 4: Voice Output Button
            const speakButton = document.createElement('button');
            speakButton.innerHTML = '🔊';
            speakButton.title = 'Read aloud';
            speakButton.onclick = () => speakText(originalText);
            actionsContainer.appendChild(speakButton);

            // Feature 14: Smart Rewriting Button
            const rephraseButton = document.createElement('button');
            rephraseButton.innerHTML = '🔁';
            rephraseButton.title = 'Rephrase this';
            rephraseButton.onclick = () => handleRephraseMessage(originalText, messageId);
            actionsContainer.appendChild(rephraseButton);
            
            messageElement.appendChild(actionsContainer);
        }
        
        // --- FEATURE 4: Voice Output ---
        function speakText(text) {
            if (!('speechSynthesis' in window)) {
                alert("Sorry, your browser doesn't support text-to-speech.");
                return;
            }
            // Strip markdown for cleaner speech
            const plainText = text.replace(/[*_`~#>|]/g, ''); // Basic stripping
            const utterance = new SpeechSynthesisUtterance(plainText);
            utterance.lang = 'en-US'; // Can be made configurable
            speechSynthesis.cancel(); // Cancel any previous speech
            speechSynthesis.speak(utterance);
        }

        // --- FEATURE 5: Voice Input ---
        function setupSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) {
                speechRecognition = new webkitSpeechRecognition();
                speechRecognition.continuous = false; // Capture a single phrase
                speechRecognition.interimResults = false;
                speechRecognition.lang = 'en-US';

                speechRecognition.onstart = () => {
                    micButton.classList.add('recording');
                    micButton.textContent = '🎙️';
                    userInput.placeholder = "Listening...";
                };
                speechRecognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    userInput.value = transcript;
                    // Optionally auto-send: handleSendMessage();
                };
                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    userInput.placeholder = "Mic error. Try typing.";
                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        alert("Microphone access denied. Please enable it in your browser settings.");
                    }
                };
                speechRecognition.onend = () => {
                    micButton.classList.remove('recording');
                    micButton.textContent = '🎤';
                    userInput.placeholder = "Ask me anything...";
                    userInput.focus();
                };
            } else {
                micButton.style.display = 'none'; // Hide mic button if not supported
                console.warn("Speech recognition not supported in this browser.");
            }
        }
        micButton.addEventListener('click', () => {
            if (speechRecognition) {
                try {
                    speechRecognition.start();
                } catch(e) {
                    // Handle cases where it might already be started or other errors.
                    console.error("Could not start speech recognition: ", e);
                    micButton.classList.remove('recording');
                    micButton.textContent = '🎤';
                }
            } else {
                alert("Speech recognition is not available.");
            }
        });
        
        // --- FEATURE 7: Conversation Export ---
        exportChatButton.addEventListener('click', () => {
            const chatData = {
                threadId: currentChatThreadId,
                persona: personaSelect.value,
                history: conversationHistory,
                exportedAt: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(chatData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `chat_export_${currentChatThreadId}_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        });

        // --- FEATURE 8: Persistent Chat Threads (Basic localStorage implementation) ---
        function loadChatThreads() {
            const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
            threadList.innerHTML = ''; // Clear existing list
            if (Object.keys(threads).length === 0) { // Create default if none exist
                threads['default_chat'] = { name: 'General Chat', lastUpdated: Date.now(), history: [] };
                localStorage.setItem('chatThreads', JSON.stringify(threads));
            }
            // Ensure currentChatThreadId is valid or default
            currentChatThreadId = threads[currentChatThreadId] ? currentChatThreadId : Object.keys(threads)[0];
            
            for (const threadId in threads) {
                const thread = threads[threadId];
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = thread.name || `Chat ${threadId.substring(0,5)}`;
                button.dataset.threadId = threadId;
                if (threadId === currentChatThreadId) button.classList.add('active');
                button.onclick = () => switchChatThread(threadId);
                li.appendChild(button);
                threadList.appendChild(li);
            }
            localStorage.setItem('lastActiveThreadId', currentChatThreadId);
        }

        function switchChatThread(threadId) {
            saveConversation(currentChatThreadId); // Save current before switching
            currentChatThreadId = threadId;
            loadConversation(threadId);
            // Update active button in sidebar
            document.querySelectorAll('#threadList button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.threadId === threadId);
            });
            localStorage.setItem('lastActiveThreadId', currentChatThreadId);
        }

        newThreadButton.addEventListener('click', () => {
            const newThreadName = prompt("Enter name for new chat thread:", `Chat Session ${Object.keys(JSON.parse(localStorage.getItem('chatThreads') || '{}')).length + 1}`);
            if (newThreadName) {
                saveConversation(currentChatThreadId); // Save current
                const newThreadId = `thread_${Date.now()}`;
                const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
                threads[newThreadId] = { name: newThreadName, lastUpdated: Date.now(), history: [] };
                localStorage.setItem('chatThreads', JSON.stringify(threads));
                currentChatThreadId = newThreadId;
                loadChatThreads(); // Refresh sidebar
                loadConversation(newThreadId); // Load the new empty chat
            }
        });

        function saveConversation(threadId) {
            if (!threadId) return;
            const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
            if (!threads[threadId]) threads[threadId] = { name: `Chat ${threadId.substring(0,5)}`, history: [] };
            threads[threadId].history = conversationHistory;
            threads[threadId].lastUpdated = Date.now();
            localStorage.setItem('chatThreads', JSON.stringify(threads));
        }

        function loadConversation(threadId) {
            if (!threadId) threadId = 'default_chat';
            currentChatThreadId = threadId;
            const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
            const thread = threads[threadId];
            
            chatWindow.innerHTML = ''; // Clear current messages
            if (thread && thread.history) {
                conversationHistory = thread.history;
                conversationHistory.forEach(msg => addMessageToChat(msg.content, msg.role, false, msg.id || generateMessageId()));
            } else {
                conversationHistory = []; // Start fresh if no history
            }
            scrollToBottom();
        }

        // --- FEATURE 11: Suggested Prompts ---
        function displaySuggestedPrompts() {
            const suggestions = [
                "Tell me a fun fact.", "Explain quantum computing simply.", 
                "What's the weather like in Paris?", "Draft an email to my boss.",
                "Suggest a recipe for dinner.", "/joke"
            ];
            suggestionsContainer.innerHTML = ''; // Clear old ones
            suggestions.forEach(text => {
                const btn = document.createElement('button');
                btn.textContent = text;
                btn.onclick = () => {
                    userInput.value = text;
                    handleSendMessage();
                    suggestionsContainer.style.display = 'none'; // Hide after click
                };
                suggestionsContainer.appendChild(btn);
            });
        }
        userInput.addEventListener('focus', () => { 
            if(conversationHistory.length <= 1) suggestionsContainer.style.display = 'flex'; 
        });


        // --- FEATURE 12: Emotion Awareness (Placeholder - client-side detection for demo) ---
        function detectEmotion(text) {
            const lowerText = text.toLowerCase();
            if (lowerText.includes("angry") || lowerText.includes("annoyed") || lowerText.includes("frustrated")) return "angry";
            if (lowerText.includes("sad") || lowerText.includes("upset") || lowerText.includes("crying")) return "sad";
            if (lowerText.includes("happy") || lowerText.includes("excited") || lowerText.includes("yay")) return "happy";
            return "neutral";
            // In a real app, this might be passed to the AI or used to subtly change UI.
        }

        // --- FEATURE 13: Info Tooltips (Basic Example) ---
        function addInfoTooltipsToMessage(messageElement, text) {
            const knownFacts = { "Paris": "Capital of France.", "GPT-4": "A large language model by OpenAI." };
            for (const fact in knownFacts) {
                if (text.includes(fact)) {
                    const regex = new RegExp(`\\b(${fact})\\b`, 'gi');
                    messageElement.innerHTML = messageElement.innerHTML.replace(regex, `$1 <span class="info-tooltip" title="${knownFacts[fact]}">ℹ️</span>`);
                }
            }
        }
        
        // --- FEATURE 14: Smart Rewriting (Handler) ---
        async function handleRephraseMessage(originalText, originalMessageId) {
            const userPrompt = `Rephrase this: "${originalText}"`;
            // Add a temporary message indicating rephrasing
            addMessageToChat(`(Attempting to rephrase your last message...)`, 'user', false, generateMessageId());
            
            const rephrasedText = await fetchAIResponseFromServer(userPrompt, conversationHistory, personaSelect.value);
            
            // Find the original message element to replace or update
            const originalMsgElement = document.getElementById(originalMessageId);
            if (originalMsgElement) {
                 originalMsgElement.innerHTML = marked.parse(sanitizeHTML(`(Rephrased): ${rephrasedText}`));
                 Prism.highlightAllUnder(originalMsgElement);
            } else { // Or append as new
                addMessageToChat(`(Rephrased): ${rephrasedText}`, 'bot', false, generateMessageId());
            }
            updateConversationHistory('assistant', `(Rephrased): ${rephrasedText}`, originalMessageId, true); // Mark as replacement
            saveConversation(currentChatThreadId);
        }
        
        // --- PERSONALIZATION (Simulated "Learning") ---
        // Example: Remembering user's name (already partially done)
        function extractAndStoreUserName(promptText) {
            const lowerPrompt = promptText.toLowerCase();
            let nameFound = null;
            if (lowerPrompt.includes("my name is ")) {
                nameFound = lowerPrompt.split("my name is ")[1].split(" ")[0];
            } else if (lowerPrompt.includes("call me ")) {
                nameFound = lowerPrompt.split("call me ")[1].split(" ")[0];
            }
            if (nameFound) {
                userName = nameFound.charAt(0).toUpperCase() + nameFound.slice(1);
                localStorage.setItem('userName', userName); // Persist
                console.log("Username stored:", userName);
            }
        }


        function updateConversationHistory(role, content, id, replace = false) {
            if (replace) {
                const existingMsgIndex = conversationHistory.findIndex(msg => msg.id === id);
                if (existingMsgIndex !== -1) {
                    conversationHistory[existingMsgIndex] = { role, content, id };
                    return;
                }
            }
            conversationHistory.push({ role, content, id });
        }

        async function handleSendMessage(event) {
            if (event) event.preventDefault();
            const messageText = userInput.value.trim();
            if (messageText === '') return;

            const userMessageId = generateMessageId();
            addMessageToChat(messageText, 'user', false, userMessageId);
            updateConversationHistory('user', messageText, userMessageId);
            extractAndStoreUserName(messageText); // Personalization
            userInput.value = '';
            suggestionsContainer.style.display = 'none'; // Hide suggestions

            const currentPersona = personaSelect.value;
            const typingIndicator = addMessageToChat('', 'bot', true, generateMessageId());
            sendButton.disabled = true;
            userInput.disabled = true;

            // --- CHOOSE STREAMING OR NORMAL RESPONSE ---
            const useStreaming = true; // Set to true to try streaming

            if (useStreaming) { // Feature 3
                const reader = await fetchAIResponseFromServer(messageText, conversationHistory.slice(0, -1), currentPersona, true);
                if (typeof reader === 'string') { // Error occurred, reader is the error message
                    typingIndicator.remove();
                    const botMessageId = generateMessageId();
                    addMessageToChat(reader, 'bot', false, botMessageId);
                    updateConversationHistory('assistant', reader, botMessageId);
                    sendButton.disabled = false;
                    userInput.disabled = false;
                } else { // Is a ReadableStreamReader
                    typingIndicator.remove(); // Remove "typing..."
                    const botMessageId = generateMessageId();
                    const botMessageElement = addMessageToChat('', 'bot', false, botMessageId); // Create empty message shell
                    botMessageElement.innerHTML = '▋'; // Initial cursor
                    await handleStreamedResponse(reader, botMessageElement, botMessageId);
                    // History updated within handleStreamedResponse
                }
            } else { // Normal non-streaming response
                const aiResponseText = await fetchAIResponseFromServer(messageText, conversationHistory.slice(0, -1), currentPersona);
                typingIndicator.remove();
                const botMessageId = generateMessageId();
                addMessageToChat(aiResponseText, 'bot', false, botMessageId);
                updateConversationHistory('assistant', aiResponseText, botMessageId);
                sendButton.disabled = false;
                userInput.disabled = false;
            }
            saveConversation(currentChatThreadId); // Feature 8
        }

        // --- UTILITY FUNCTIONS (Scroll, Prune DOM, Viewport Height) ---
        function scrollToBottom() { if(chatWindow) setTimeout(() => { chatWindow.scrollTop = chatWindow.scrollHeight; },0); }
        function pruneOldMessagesDOM() {
            while (chatWindow.children.length > MAX_MESSAGES_DISPLAY) {
                chatWindow.removeChild(chatWindow.firstChild);
            }
        }
        function applyViewportHeight() { /* ... (same as before) ... */ }
        function loadTheme() { /* ... (same as before) ... */ 
            const savedTheme = localStorage.getItem('theme');
            document.body.classList.toggle('dark-mode', savedTheme === 'dark');
            updateThemePreference();
        }
        function updateThemePreference() { /* ... (same as before) ... */ 
            const isDarkMode = document.body.classList.contains('dark-mode');
            if (themeToggleIcon) themeToggleIcon.textContent = isDarkMode ? '☀️' : '🌙';
            if (themeToggleText) themeToggleText.textContent = isDarkMode ? 'Light' : 'Dark';
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
        }
        
        // --- EVENT LISTENERS ---
        chatForm.addEventListener('submit', handleSendMessage);
        themeToggleButton.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            updateThemePreference();
        });
        // Add other listeners (personaSelect, etc. if they need to trigger actions on change)
        // personaSelect.addEventListener('change', () => { /* Maybe clear chat or warn user? */ });

        // --- INITIALIZE ---
        initializeChat();
        setupSpeechRecognition(); // Feature 5

        // Make Prism.js highlightAll available globally IF NEEDED, or call it specifically
        // window.Prism = Prism; // If you need to call Prism.highlightElement manually elsewhere
    });
    </script>
</body>
</html>
