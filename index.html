<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>AI ChatBot by Taylan - Pro Refinements</title>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js" data-manual></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js" data-manual></script>


    <style>
        /* --- Root Variables (Themes) --- */
        :root {
            --body-bg-light: #f4f6f8; --body-bg-dark: #0d1117;
            /* ... (all other theme variables from previous version) ... */
            --vh: 1vh; /* Fallback for dynamic viewport height unit */
            --suggestion-bg-light: #e0e0e0; --suggestion-bg-dark: #2a2a2a;
            --suggestion-text-light: #333; --suggestion-text-dark: #ccc;
            --rephrased-bg-light: #f0f0f0; --rephrased-bg-dark: #282c34;
            --rephrased-text-light: #555; --rephrased-text-dark: #aaa;

            /* Default to light theme */
            --body-bg: var(--body-bg-light); /* ... etc. ... */
            --vh-actual: calc(var(--vh, 1vh) * 100); /* Actual viewport height */
            --suggestion-bg: var(--suggestion-bg-light); --suggestion-text: var(--suggestion-text-light);
            --rephrased-bg: var(--rephrased-bg-light); --rephrased-text: var(--rephrased-text-light);
        }
        body.dark-mode {
            --body-bg: var(--body-bg-dark); /* ... etc. ... */
            --suggestion-bg: var(--suggestion-bg-dark); --suggestion-text: var(--suggestion-text-dark);
            --rephrased-bg: var(--rephrased-bg-dark); --rephrased-text: var(--rephrased-text-dark);
        }

        /* --- General Styles & Mobile Optimizations --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        html { height: 100%; }
        body {
            background-color: var(--body-bg); color: var(--text-color);
            display: flex; flex-direction: row;
            height: var(--vh-actual); /* Use CSS variable for dynamic viewport height */
            min-height: var(--vh-actual);
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden; /* Prevent body scroll, individual panels will scroll */
        }

        /* --- Sidebar (Threads) --- */
        .threads-sidebar {
            width: 260px; /* Slightly wider */
            background-color: var(--chat-bg); border-right: 1px solid var(--border-color);
            padding: 15px; display: flex; flex-direction: column;
            transition: background-color 0.3s, border-color 0.3s, transform 0.3s ease-in-out;
            transform: translateX(-100%); /* Hidden by default on small screens */
            position: absolute; /* For overlay on mobile */
            z-index: 1000; height: var(--vh-actual);
        }
        .threads-sidebar.open { transform: translateX(0); }
        .threads-sidebar h3 { margin-bottom: 10px; font-size: 1.1em; color: var(--text-color); display: flex; justify-content: space-between; align-items: center;}
        #closeSidebarButton { background:none; border:none; font-size:1.2em; color: var(--text-color); cursor:pointer; display:none; }
        .threads-sidebar ul { list-style: none; flex-grow: 1; overflow-y: auto; }
        .threads-sidebar li button { /* ... (styling from before, ensure good contrast) ... */
            width: 100%; text-align: left; padding: 10px 8px; margin-bottom: 5px;
            background: none; border: 1px solid transparent; color: var(--text-color);
            border-radius: 6px; cursor: pointer; font-size: 0.9em;
        }
        .threads-sidebar li button:hover, .threads-sidebar li button.active {
            background-color: var(--bot-msg-bg); border-color: var(--button-bg);
        }
        #newThreadButton { margin-top: 10px; padding: 10px; font-weight: bold; /* ... use button-bg, button-text ... */ }

        /* --- Main Chat Area --- */
        .chat-area {
            flex-grow: 1; display: flex; flex-direction: column;
            height: var(--vh-actual); /* Full dynamic height */
            position: relative; /* For sidebar overlay behavior */
        }
        .chat-container { /* Main chat view */
            width: 100%; flex-grow: 1; background-color: var(--chat-bg);
            box-shadow: var(--shadow); display: flex; flex-direction: column;
            overflow: hidden; transition: background-color 0.3s;
        }
        /* ... (flash animation from before) ... */

        /* --- Header --- */
        .chat-header {
            padding: 10px 15px; background-color: var(--header-bg); color: var(--header-text);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color); transition: all 0.3s; flex-shrink: 0;
        }
        #sidebarToggleButton { background:none; border:none; font-size:1.5em; color:var(--header-text); cursor:pointer; margin-right:10px; display:none; }
        .chat-header h2 { /* ... (branding subtitle styling from before) ... */ }
        .header-controls { display: flex; align-items: center; gap: 10px; }
        /* ... (header controls styling from before) ... */

        /* --- Chat Window & Messages --- */
        .chat-window { /* ... (scrollbar styling from before) ... */
            flex-grow: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px;
        }
        .message { /* ... (fadeInMessage animation) ... */
             position: relative; /* For actions & tooltips */
        }
        .message.fading-out { /* For smooth DOM pruning */
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .message.bot.rephrased {
            background-color: var(--rephrased-bg);
            color: var(--rephrased-text);
            font-style: italic;
            border-left: 3px solid var(--button-bg);
        }
        .rephrased-label { font-size: 0.8em; opacity: 0.7; display: block; margin-bottom: 3px; }
        .streaming-cursor { aria-hidden: true; role: presentation; } /* Hide from assistive tech */
        /* ... (user, bot, typing, message-actions styling from before) ... */

        /* --- Suggestions & Input Form --- */
        /* ... (suggestions-container styling from before) ... */
        .chat-input-form { /* ... (styling from before) ... */ }
        #micButton { /* ... (styling from before, add tooltip on disabled/error state) ... */ }
        #userInput { /* ... (styling from before) ... */ }
        #sendButton { /* ... (styling from before) ... */ }
        #sendButton.loading .spinner {
            display: inline-block; width: 1em; height: 1em;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; border-top-color: #fff;
            animation: spin 1s ease-infinite; margin-right: 5px; vertical-align: middle;
        }
        #sendButton.loading .send-text { display: none; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ... (Markdown & Prism styling from before) ... */
        /* ... (Info tooltip styling from before) ... */

        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) { /* Mobile specific sidebar toggle */
            #sidebarToggleButton { display: inline-block; }
            .threads-sidebar { box-shadow: 0 0 15px rgba(0,0,0,0.2); } /* Add shadow when overlayed */
            #closeSidebarButton { display: inline-block; }
        }
        /* ... (other media queries from before) ... */

    </style>
</head>
<body>
    <aside class="threads-sidebar" id="threadsSidebar">
        <h3>
            Chat Threads
            <button id="closeSidebarButton" aria-label="Close sidebar">&times;</button>
        </h3>
        <ul id="threadList"></ul>
        <button id="newThreadButton" class="header-controls button">New Chat +</button>
    </aside>

    <main class="chat-area">
        <div class="chat-container" id="chatAppContainer">
            <header class="chat-header">
                <button id="sidebarToggleButton" aria-label="Toggle chat threads sidebar">â˜°</button>
                <h2>
                    <span class="title-main">AI Assistant</span>
                    <span class="title-subtitle">by Taylan</span>
                </h2>
                <div class="header-controls">
                    <label for="personaSelect" class="visually-hidden">Persona:</label> <select id="personaSelect" aria-label="Select AI Persona">
                        </select>
                    <button id="exportChatButton" aria-label="Export current chat">Export Chat</button>
                    <button id="theme-toggle" aria-label="Toggle color theme">
                        <span class="icon"></span> <span class="text">Theme</span>
                    </button>
                </div>
            </header>
            <div class="suggestions-container" id="suggestionsContainer"></div>
            <div class="chat-window" id="chatWindow" role="log" aria-live="polite"></div>
            <form class="chat-input-form" id="chatForm">
                <button type="button" id="micButton" aria-label="Use microphone" title="Use microphone">ðŸŽ¤</button>
                <input type="text" id="userInput" placeholder="Ask me anything..." autocomplete="off" aria-label="User message input" role="textbox">
                <button type="submit" id="sendButton" aria-label="Send message">
                    <span class="spinner" style="display:none;"></span>
                    <span class="send-text">Send</span>
                </button>
            </form>
        </div>
    </main>

    <script defer>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element Variables ---
        const chatAppContainer = document.getElementById('chatAppContainer');
        // ... (all other DOM element vars from previous version) ...
        const personaSelect = document.getElementById('personaSelect');
        const exportChatButton = document.getElementById('exportChatButton');
        const suggestionsContainer = document.getElementById('suggestionsContainer');
        const micButton = document.getElementById('micButton');
        const threadsSidebar = document.getElementById('threadsSidebar');
        const threadList = document.getElementById('threadList');
        const newThreadButton = document.getElementById('newThreadButton');
        const sidebarToggleButton = document.getElementById('sidebarToggleButton');
        const closeSidebarButton = document.getElementById('closeSidebarButton');
        const sendButtonSpinner = sendButton.querySelector('.spinner');
        const sendButtonText = sendButton.querySelector('.send-text');

        // --- State Variables ---
        let conversationHistory = [];
        let currentChatThreadId = localStorage.getItem('lastActiveThreadId') || 'default_chat';
        let userName = localStorage.getItem('userName') || null;
        let currentPersona = localStorage.getItem('selectedPersona') || 'helpful'; // Cache persona
        // ... (other state vars from previous version) ...
        let isRecognizingSpeech = false; // For mic button state
        let sendDebounceTimer; // For rate limiting send button

        // --- INITIALIZATION ---
        function initializeChat() {
            // Check for external library loads
            if (typeof DOMPurify === 'undefined') console.warn('DOMPurify library not loaded! Markdown sanitization will be basic.');
            if (typeof marked === 'undefined') console.warn('Marked.js library not loaded! Markdown will not be parsed.');
            if (typeof Prism === 'undefined' || !Prism.highlightAllUnder) console.warn('Prism.js library not loaded! Syntax highlighting will not work.');

            loadTheme();
            applyViewportHeight(); // Mobile optimization for viewport height
            personaSelect.value = currentPersona; // Set dropdown from cache

            loadChatThreads(); // Loads threads and sets currentChatThreadId
            loadConversation(currentChatThreadId); // Load default/last active thread
            
            displaySuggestedPrompts();
            setupSpeechRecognition();
            
            if (!conversationHistory.length) {
                const greeting = generateGreeting(currentPersona); // Use cached/selected persona
                const greetingId = generateMessageId();
                addMessageToChat(greeting, 'bot', false, greetingId);
                updateConversationHistory('assistant', greeting, greetingId);
                saveConversation(currentChatThreadId); // Save greeting to new/empty thread
            }
            
            if (!initialFocusDone && window.innerWidth > 768) { // Don't auto-focus on mobile where keyboard can be intrusive
                userInput.focus();
                initialFocusDone = true;
            }
            setTimeout(scrollToBottom, 100);
        }
        
        // --- MODULARIZATION & BACKEND NOTES ---
        // This single JS block is very large. For scaling up:
        // 1. Split into modules: ui.js, chatApi.js, features.js, main.js, etc.
        // 2. Use <script type="module"> and import/export.
        // 3. Backend API routes (/api/chat, /api/chat-stream) need to be robust:
        //    - Proper error handling, status codes.
        //    - Timeout handling for AI API calls.
        //    - Consider a simple retry mechanism (e.g., on 5xx errors from AI provider, retry once).

        // --- UI/UX REFINEMENTS ---
        function toggleSendButtonLoading(isLoading) {
            if (isLoading) {
                sendButton.disabled = true;
                if(sendButtonSpinner) sendButtonSpinner.style.display = 'inline-block';
                if(sendButtonText) sendButtonText.style.display = 'none';
            } else {
                sendButton.disabled = false;
                if(sendButtonSpinner) sendButtonSpinner.style.display = 'none';
                if(sendButtonText) sendButtonText.style.display = 'inline-block';
                userInput.disabled = false; // Re-enable input
                userInput.focus(); // Auto-focus improvement
            }
        }

        // --- MOBILE OPTIMIZATION ---
        function applyViewportHeight() {
            const setVhUnit = () => {
                document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
            };
            setVhUnit();
            // Update on resize, but debounce it for performance
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(setVhUnit, 100);
            });
            // Also listen to visualViewport for keyboard changes etc.
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                     clearTimeout(resizeTimeout);
                     resizeTimeout = setTimeout(setVhUnit, 100); // ensure CSS var is updated
                     scrollToBottom(); // Ensure content is visible
                });
            }
        }

        sidebarToggleButton.addEventListener('click', () => threadsSidebar.classList.add('open'));
        closeSidebarButton.addEventListener('click', () => threadsSidebar.classList.remove('open'));
        // Close sidebar if user clicks outside of it on mobile (optional)
        document.addEventListener('click', (event) => {
            if (threadsSidebar.classList.contains('open') && 
                !threadsSidebar.contains(event.target) && 
                !sidebarToggleButton.contains(event.target)) {
                threadsSidebar.classList.remove('open');
            }
        });

        // --- CHAT FEATURES ---
        function generateGreeting(persona) { /* ... (same as before) ... */ }
        function generateMessageId() { /* ... (same as before) ... */ }

        async function fetchAIResponseFromServer(promptText, history, persona, stream = false) {
            const endpoint = stream ? '/api/chat-stream' : '/api/chat';
            // Basic timeout for fetch (can be more sophisticated with AbortController)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: promptText, 
                        history: history,
                        persona: persona,
                        emotion: detectEmotion(promptText) // Feature: Emotion Awareness Extension
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId); // Clear timeout if response received

                if (!response.ok) { /* ... (error handling from before) ... */ 
                    const errorData = await response.json().catch(() => ({ detail: "Unknown server error" }));
                    return `Error ${response.status}: ${errorData.detail || response.statusText}. (Backend issue?)`;
                }
                return stream ? response.body.getReader() : (await response.json()).reply || "No reply from AI.";
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') return "Request to AI timed out. Please try again.";
                console.error('Network/Fetch Error:', error);
                return "Network error. Could not reach AI. (Backend down?)";
            }
        }

        async function handleStreamedResponse(reader, botMessageElement, botMessageId) {
            const decoder = new TextDecoder();
            let fullText = '';
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    fullText += chunk;
                    // Streaming Cursor: Hide from assistive tech
                    const streamingCursor = `<span class="streaming-cursor" aria-hidden="true" role="presentation">â–‹</span>`;
                    botMessageElement.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(fullText + streamingCursor)) : marked.parse(sanitizeHTML(fullText + streamingCursor));
                    scrollToBottom();
                }
            } catch (error) { /* ... */ } finally {
                botMessageElement.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(fullText)) : marked.parse(sanitizeHTML(fullText));
                Prism.highlightAllUnder(botMessageElement);
                updateConversationHistory('assistant', fullText, botMessageId);
                saveConversation(currentChatThreadId);
                toggleSendButtonLoading(false); // Re-enable after stream
            }
        }

        // --- SECURITY & SAFETY (Markdown) ---
        function sanitizeHTML(text) { /* Basic fallback if DOMPurify fails */
            console.warn("Using basic HTML sanitization. For production, ensure DOMPurify is loaded.");
            const temp = document.createElement('div'); temp.textContent = text; return temp.innerHTML;
        }

        function addMessageToChat(text, sender, isTyping = false, messageId, isRephrased = false) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', sender);
            if (isRephrased) messageElement.classList.add('rephrased'); // Rephrased Message Labeling
            messageElement.id = messageId;
            messageElement.setAttribute('aria-atomic', 'true');
            if (isTyping) messageElement.setAttribute('aria-label', 'Bot is typing...'); // Typing Indicator Accessibility

            if (isTyping) { /* ... */ } else {
                if (sender === 'user') { messageElement.textContent = text; } else {
                    let htmlContent = marked.parse(text); // Parse first
                    htmlContent = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(htmlContent) : sanitizeHTML(htmlContent); // Then sanitize
                    if (isRephrased) htmlContent = `<span class="rephrased-label">Rephrased:</span>` + htmlContent;
                    messageElement.innerHTML = htmlContent;
                    Prism.highlightAllUnder(messageElement); // Must be after innerHTML is set
                    addMessageActions(messageElement, text, messageId);
                    addInfoTooltipsToMessage(messageElement, text);
                }
            }
            chatWindow.appendChild(messageElement);
            pruneOldMessagesDOM();
            scrollToBottom();
            /* ... (flash animation) ... */
            return messageElement;
        }
        
        function addMessageActions(messageElement, originalText, messageId) { /* ... (same as before) ... */ }
        function speakText(text) { /* ... (same as before, consider more robust markdown stripping) ... */ }

        function setupSpeechRecognition() {
             if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) { // Standard check
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                speechRecognition = new SpeechRecognition();
                /* ... (rest of setup from before) ... */
                speechRecognition.onresult = (event) => {
                    const transcript = event.results[event.results.length - 1][0].transcript; // Get final transcript
                    userInput.value = transcript;
                    handleSendMessage(); // Auto-send after capture
                };
                speechRecognition.onerror = (event) => { /* ... */ 
                    micButton.title = `Mic error: ${event.error}. Click to try again.`;
                };
             } else { /* ... */ micButton.title = "Speech recognition not supported."; }
        }
        micButton.addEventListener('click', () => {
            if (!speechRecognition) { alert("Speech recognition is not available/supported."); return; }
            if (isRecognizingSpeech) {
                speechRecognition.stop(); isRecognizingSpeech = false;
            } else {
                try { speechRecognition.start(); isRecognizingSpeech = true; } catch(e) { /* ... */ }
            }
        }); // Modified to toggle if already recognizing
        
        personaSelect.addEventListener('change', () => {
            currentPersona = personaSelect.value;
            localStorage.setItem('selectedPersona', currentPersona); // Cache control for persona
            // Optional: Start a new chat or modify current system prompt if AI supports dynamic system messages
            // For now, new persona applies to next full message send.
        });

        exportChatButton.addEventListener('click', () => {
            const threads = JSON.parse(localStorage.getItem('chatThreads') || '{}');
            const currentThread = threads[currentChatThreadId] || { name: "Chat" };
            const chatTitle = currentThread.name.replace(/[^a-z0-9]/gi, '_').toLowerCase(); // Sanitize for filename

            const chatData = { /* ... */ };
            const a = document.createElement('a'); /* ... */
            a.download = `chat_export_${chatTitle}_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`; // Include Chat Title in Filename
            /* ... */
        });
        
        // --- PERFORMANCE (DOM Pruning & Rate Limiting) ---
        function pruneOldMessagesDOM() {
            while (chatWindow.children.length > MAX_MESSAGES_DISPLAY) {
                const oldMsg = chatWindow.firstChild;
                oldMsg.classList.add('fading-out'); // Add fade out class
                setTimeout(() => { oldMsg.remove(); }, 300); // Remove after animation
            }
        }

        function displaySuggestedPrompts() { /* ... (same as before) ... */ }
        function detectEmotion(text) { /* ... (same as before) ... */ }
        function addInfoTooltipsToMessage(messageElement, text) { /* ... (same as before) ... */ }
        async function handleRephraseMessage(originalText, originalMessageId) { /* ... (add visual distinction to rephrased message) ... */ 
            const userPrompt = `[User seems ${detectEmotion(originalText)}] Rephrase this following content: "${originalText}"`; // Emotion awareness
            toggleSendButtonLoading(true);
            const rephrasedText = await fetchAIResponseFromServer(userPrompt, conversationHistory, currentPersona);
            toggleSendButtonLoading(false);

            const newMsgId = generateMessageId();
            addMessageToChat(rephrasedText, 'bot', false, newMsgId, true); // Pass true for isRephrased
            updateConversationHistory('assistant', rephrasedText, newMsgId);
            saveConversation(currentChatThreadId);
        }
        function extractAndStoreUserName(promptText) { /* ... (same as before) ... */ }
        function updateConversationHistory(role, content, id, replace = false) { /* ... (same as before) ... */ }

        async function handleSendMessage(event) {
            if (event) event.preventDefault();
            // Debounce send
            clearTimeout(sendDebounceTimer);
            sendDebounceTimer = setTimeout(async () => {
                const messageText = userInput.value.trim();
                if (messageText === '') return;
                toggleSendButtonLoading(true); // Loading animation
                /* ... (rest of handleSendMessage logic from previous version, ensuring toggleSendButtonLoading(false) is called in all exit paths) ... */
                
                const userMessageId = generateMessageId();
                addMessageToChat(messageText, 'user', false, userMessageId);
                updateConversationHistory('user', messageText, userMessageId);
                extractAndStoreUserName(messageText);
                userInput.value = '';
                suggestionsContainer.style.display = 'none';

                const currentEmotion = detectEmotion(messageText); // Emotion Awareness
                const promptForAI = `[User seems ${currentEmotion}] ${messageText}`; // Modify prompt

                const useStreaming = true; 
                if (useStreaming) {
                    const reader = await fetchAIResponseFromServer(promptForAI, conversationHistory.slice(0, -1), currentPersona, true);
                    if (typeof reader === 'string') { /* Error handling */ 
                        addMessageToChat(reader, 'bot', false, generateMessageId()); 
                        toggleSendButtonLoading(false); 
                    } else {
                        const botMessageId = generateMessageId();
                        const botMsgElem = addMessageToChat('', 'bot', false, botMessageId);
                        botMsgElem.innerHTML = '<span class="streaming-cursor" aria-hidden="true" role="presentation">â–‹</span>';
                        await handleStreamedResponse(reader, botMsgElem, botMessageId); 
                        // toggleSendButtonLoading(false) is called within handleStreamedResponse's finally block
                    }
                } else { /* Non-streaming ... call toggleSendButtonLoading(false) after response */ }
                saveConversation(currentChatThreadId);
            }, 300); // 300ms debounce
        }
        
        // --- THREADS, THEME, UTILITIES ---
        function loadChatThreads() { /* ... (same as before, ensure currentChatThreadId loaded from localStorage.getItem('lastActiveThreadId')) ... */ }
        function switchChatThread(threadId) { /* ... (same as before) ... */ }
        function saveConversation(threadId) { /* ... (same as before) ... */ }
        function loadConversation(threadId) { /* ... (same as before) ... */ }
        function scrollToBottom() { /* ... (same as before) ... */ }
        function loadTheme() { /* ... (same as before) ... */ }
        function updateThemePreference() { /* ... (same as before) ... */ }
        
        // --- INITIALIZE ---
        initializeChat();
    });
    </script>
</body>
</html>
