<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Evidence Lockdown: Rhythm Scan V3.1 (Fixes & Enhancements)</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      color: #E0E0E0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      /* touch-action will be set in JS */
    }
    canvas {
      display: block;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      /* touch-action will be set in JS */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let screenWidth, screenHeight;
    let gameRunning = false;
    let gamePaused = false;
    let animationFrameId;

    // --- Difficulty Settings ---
    const difficulties = {
        Easy:   { BPM: 75, SCANNER_SPEED_MS: 0.10, SPAWN_CHANCE: 0.55, ITEM_DURATION_BEATS: 4.5, SCORE_SPEED_FACTOR: 0.000005 },
        Normal: { BPM: 90, SCANNER_SPEED_MS: 0.13, SPAWN_CHANCE: 0.65, ITEM_DURATION_BEATS: 4.0, SCORE_SPEED_FACTOR: 0.000007 },
        Hard:   { BPM: 110,SCANNER_SPEED_MS: 0.16, SPAWN_CHANCE: 0.75, ITEM_DURATION_BEATS: 3.5, SCORE_SPEED_FACTOR: 0.00001 }
    };
    let currentDifficultySetting = difficulties.Normal;
    let difficultySelection = ['Normal', 'Easy', 'Hard'];
    let selectedDifficultyIndex = 0;

    let currentBeatInterval = 60000 / currentDifficultySetting.BPM;
    let lastBeatTime = 0;
    let beatCount = 0;

    const SCANNER_COLOR_BASE = 'rgba(0, 255, 255, 0.7)';
    let scannerColor = SCANNER_COLOR_BASE;
    const SCANNER_WIDTH = 8;
    let scannerX = 0;
    let baseScannerSpeedMs = currentDifficultySetting.SCANNER_SPEED_MS;
    let currentScannerSpeedMs = baseScannerSpeedMs;
    let scannerDirection = 1;
    const MAX_SCANNER_SPEED_INCREASE_FACTOR = 1.5;

    let items = [];
    const ITEM_RADIUS_BASE = 18;
    const EVIDENCE_BASE_COLOR = 'rgba(0, 255, 0, 0.8)';
    const DISTRACTOR_COLOR = 'rgba(255, 165, 0, 0.8)';
    const POWERUP_COLOR = 'rgba(255, 0, 255, 0.9)';
    const POWERUP_FREEZE_COLOR = 'rgba(100, 150, 255, 0.9)';
    const FRAGMENT_COLOR = 'rgba(100, 200, 255, 0.8)';

    let currentItemSpawnChance = currentDifficultySetting.SPAWN_CHANCE;
    const DISTRACTOR_SPAWN_CHANCE = 0.25;
    const FRAGMENTED_EVIDENCE_SPAWN_CHANCE = 0.15;
    const POWERUP_SPAWN_CHANCE = 0.08;
    const POWERUP_TYPE_CHANCE = { focus: 0.5, freeze: 0.5 };

    let currentItemActiveDurationMs = currentBeatInterval * currentDifficultySetting.ITEM_DURATION_BEATS;
    // const PERFECT_TAP_WINDOW_MS_BASE = currentBeatInterval / 2.8; // Not used directly, calculated in handleTap

    let score = 0;
    let highScore = parseInt(localStorage.getItem('evidenceLockdownHighScoreV3') || "0"); // FIX 4: Type safety
    let combo = 0;
    const SCORE_PER_EVIDENCE = 100;
    const SCORE_PER_FRAGMENT = 75;
    const FRAGMENT_SET_COMPLETION_BONUS = 150;
    const COMBO_MULTIPLIER_BONUS = 10;
    const MAX_COMBO_FOR_METER = 15;
    const HIGH_COMBO_THRESHOLD = 7;

    const PENALTY_FOR_DISTRACTOR = -150;
    const PENALTY_FOR_MISS = -50;

    let tapFeedback = [];
    let particles = [];
    let lives = 3;
    const INITIAL_LIVES = 3;

    let evidenceCollectedCount = 0;
    let fragmentsCollectedCount = 0;
    let fragmentedSetsCompletedCount = 0;
    let distractorsHitCount = 0;
    let evidenceMissedCount = 0;
    let totalEvidenceOpportunities = 0;
    let powerUpsCollectedCount = 0;

    let focusModeActive = false;
    let focusModeEndTime = 0;
    const FOCUS_MODE_DURATION_MS = 7000;
    const FOCUS_MODE_SPEED_MULTIPLIER = 0.6;

    let freezeModeActive = false;
    let freezeModeEndTime = 0;
    const FREEZE_MODE_DURATION_MS = 3500;

    const evidenceTypes = ['key', 'phone', 'footprint', 'document', 'sample'];
    let backgroundHue = 200;

    function getRandom(min, max) { return Math.random() * (max - min) + min; }
    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function resizeCanvas() {
      screenWidth = window.innerWidth;
      screenHeight = window.innerHeight;
      canvas.width = screenWidth;
      canvas.height = screenHeight;
      scannerX = SCANNER_WIDTH / 2;
      // FIX 6: Improved Game Over/Start Screen Handling on Resize
      if (!gameRunning) {
          if (lives <= 0) drawEndGameReport();
          else drawStartScreen();
      } else {
          draw();
      }
    }

    function cycleDifficulty() {
        selectedDifficultyIndex = (selectedDifficultyIndex + 1) % difficultySelection.length;
        currentDifficultySetting = difficulties[difficultySelection[selectedDifficultyIndex]];
        baseScannerSpeedMs = currentDifficultySetting.SCANNER_SPEED_MS;
        currentBeatInterval = 60000 / currentDifficultySetting.BPM;
        currentItemSpawnChance = currentDifficultySetting.SPAWN_CHANCE;
        currentItemActiveDurationMs = currentBeatInterval * currentDifficultySetting.ITEM_DURATION_BEATS;
        if (!gameRunning) drawStartScreen();
    }
    
    function handleTap(event) {
      if (event) event.preventDefault();
      if (!gameRunning && !gamePaused) {
        const rect = canvas.getBoundingClientRect(); // Get canvas position
        const tapY = event.clientY || (event.touches && event.touches[0].clientY);
        // Simple check for tapping the difficulty text area (approximate)
        if (tapY - rect.top > screenHeight * 0.6 && tapY - rect.top < screenHeight * 0.75) {
             cycleDifficulty();
             return;
        }
        startGame();
        return;
      }
      if (gamePaused && !freezeModeActive) return;

      const tapTime = performance.now();
      let itemHitProcessed = false;

      for (let i = items.length - 1; i >= 0; i--) {
        if (itemHitProcessed) break;
        const item = items[i];
        // const effectiveTapWindow = focusModeActive ? (currentBeatInterval / 2.8) * 1.5 : (currentBeatInterval / 2.8); // Not used directly this way

        if (Math.abs(item.x - scannerX) < item.radius + SCANNER_WIDTH + 10 &&
            tapTime >= item.spawnTime && tapTime <= item.spawnTime + currentItemActiveDurationMs) {
            if (scannerX >= item.x - item.radius && scannerX <= item.x + item.radius) {
                itemHitProcessed = true;
                let pointsEarnedThisTap = 0;

                if (item.type === 'evidence') {
                    pointsEarnedThisTap = SCORE_PER_EVIDENCE + (combo * COMBO_MULTIPLIER_BONUS);
                    score += pointsEarnedThisTap; combo++; evidenceCollectedCount++;
                    createParticleExplosion(item.x, item.y, EVIDENCE_BASE_COLOR);
                } else if (item.type === 'fragment') {
                    pointsEarnedThisTap = SCORE_PER_FRAGMENT;
                    score += pointsEarnedThisTap; fragmentsCollectedCount++;
                    createParticleExplosion(item.x, item.y, FRAGMENT_COLOR);
                    const parent = items.find(p => p.id === item.parentId && p.type === 'fragment_parent');
                    if (parent) {
                        parent.fragmentsCollected++;
                        if (parent.fragmentsCollected >= parent.totalFragments) {
                            let bonusPoints = FRAGMENT_SET_COMPLETION_BONUS;
                            score += bonusPoints; pointsEarnedThisTap += bonusPoints; 
                            fragmentedSetsCompletedCount++;
                            addTapFeedback(parent.x, parent.y, `Set! +${bonusPoints}`, EVIDENCE_BASE_COLOR, tapTime, true);
                            items = items.filter(it => it.id !== parent.id && it.parentId !== parent.id);
                        }
                    }
                } else if (item.type === 'powerup_focus') {
                    activateFocusMode(tapTime); powerUpsCollectedCount++; pointsEarnedThisTap = 0;
                    createParticleExplosion(item.x, item.y, POWERUP_COLOR);
                } else if (item.type === 'powerup_freeze') {
                    activateFreezeMode(tapTime); powerUpsCollectedCount++; pointsEarnedThisTap = 0;
                    createParticleExplosion(item.x, item.y, POWERUP_FREEZE_COLOR);
                } else if (item.type === 'distractor') {
                    score = Math.max(0, score + PENALTY_FOR_DISTRACTOR); combo = 0; lives--;
                    distractorsHitCount++; pointsEarnedThisTap = PENALTY_FOR_DISTRACTOR;
                    createParticleExplosion(item.x, item.y, DISTRACTOR_COLOR, true);
                }
                addTapFeedback(item.x, item.y, (pointsEarnedThisTap > 0 ? `+${pointsEarnedThisTap}`: `${pointsEarnedThisTap}`), item.color || item.type === 'evidence' ? EVIDENCE_BASE_COLOR : DISTRACTOR_COLOR, tapTime);
                items.splice(i, 1);
                break;
            }
        }
      }
      if (lives <= 0) gameOver();
    }

    function activateFocusMode(currentTime) { /* ... (same as V3) ... */ focusModeActive = true; freezeModeActive = false; focusModeEndTime = currentTime + FOCUS_MODE_DURATION_MS;}
    function deactivateFocusMode() { /* ... (same as V3) ... */ focusModeActive = false; }
    function activateFreezeMode(currentTime) { /* ... (same as V3) ... */ freezeModeActive = true; focusModeActive = false; freezeModeEndTime = currentTime + FREEZE_MODE_DURATION_MS; gamePaused = true;}
    function deactivateFreezeMode() { /* ... (same as V3) ... */ freezeModeActive = false; gamePaused = false; lastBeatTime = performance.now(); lastTime = performance.now(); }
    function addTapFeedback(x, y, text, color, time, isBonus = false) { /* ... (same as V3) ... */ tapFeedback.push({ x, y, text, color, spawnTime: time, alpha: 1, scale: isBonus ? 1.3 : 1 });}
    
    let itemIdCounter = 0;
    function spawnItem(currentTime) { /* ... (same logic as V3, ensure totalEvidenceOpportunities is incremented for evidence/fragment_parent) ... */ 
        if (Math.random() > currentItemSpawnChance) return;
        const spawnRoll = Math.random();
        let itemTypeToSpawn, itemIconType;

        if (spawnRoll < POWERUP_SPAWN_CHANCE) {
            itemTypeToSpawn = Math.random() < POWERUP_TYPE_CHANCE.focus ? 'powerup_focus' : 'powerup_freeze';
            itemIconType = itemTypeToSpawn === 'powerup_focus' ? 'powerup_focus_icon' : 'powerup_freeze_icon';
        } else if (spawnRoll < POWERUP_SPAWN_CHANCE + FRAGMENTED_EVIDENCE_SPAWN_CHANCE) {
            itemTypeToSpawn = 'fragment_parent';
        } else {
            itemTypeToSpawn = Math.random() < DISTRACTOR_SPAWN_CHANCE ? 'distractor' : 'evidence';
            if(itemTypeToSpawn === 'evidence') itemIconType = evidenceTypes[getRandomInt(0, evidenceTypes.length - 1)];
            else itemIconType = 'distractor_icon';
        }
        
        const x = getRandom(ITEM_RADIUS_BASE * 2.5, screenWidth - ITEM_RADIUS_BASE * 2.5);
        const y = getRandom(ITEM_RADIUS_BASE * 2.5, screenHeight - ITEM_RADIUS_BASE * 2.5);
        for (const existingItem of items) {
            if (Math.hypot(existingItem.x - x, existingItem.y - y) < ITEM_RADIUS_BASE * 5) return; 
        }
        itemIdCounter++;

        if (itemTypeToSpawn === 'fragment_parent') {
            totalEvidenceOpportunities++; 
            const numFragments = getRandomInt(2, 3);
            items.push({ id: itemIdCounter, type: 'fragment_parent', x, y, totalFragments: numFragments, fragmentsCollected: 0, spawnTime: currentTime, alpha: 0, radius: ITEM_RADIUS_BASE * 0.5 });
            const parentId = itemIdCounter;
            for (let i = 0; i < numFragments; i++) {
                itemIdCounter++;
                const angle = (i / numFragments) * Math.PI * 2 + getRandom(-0.2, 0.2);
                items.push({ id: itemIdCounter, parentId: parentId, type: 'fragment', x: x + Math.cos(angle) * ITEM_RADIUS_BASE * 2.5, y: y + Math.sin(angle) * ITEM_RADIUS_BASE * 2, radius: ITEM_RADIUS_BASE * 0.8, color: FRAGMENT_COLOR, iconType: evidenceTypes[getRandomInt(0, evidenceTypes.length-1)], spawnTime: currentTime + i * (currentBeatInterval / (numFragments * 1.5)), alpha: 0 });
            }
        } else {
            if(itemTypeToSpawn === 'evidence') totalEvidenceOpportunities++;
            items.push({ id: itemIdCounter, x, y, radius: ITEM_RADIUS_BASE, type: itemTypeToSpawn, color: itemTypeToSpawn === 'evidence' ? EVIDENCE_BASE_COLOR : (itemTypeToSpawn === 'powerup_focus' ? POWERUP_COLOR : (itemTypeToSpawn === 'powerup_freeze' ? POWERUP_FREEZE_COLOR : DISTRACTOR_COLOR)), iconType: itemIconType, spawnTime: currentTime, alpha: 0 });
        }
    }

    function updateItems(currentTime, deltaTime) {
      if (gamePaused && !freezeModeActive) return;
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (item.alpha < 1 && currentTime >= item.spawnTime) {
          // FIX 1: Corrected Syntax (removed extra parenthesis)
          item.alpha += (deltaTime / (currentBeatInterval / 2.5)); 
          item.alpha = Math.min(1, item.alpha);
        }
        
        const itemLifetime = currentItemActiveDurationMs + (item.type === 'fragment' ? currentBeatInterval : 0);
        if (item.type !== 'fragment_parent' && currentTime > item.spawnTime + itemLifetime) {
          if (item.type === 'evidence' || item.type === 'fragment') {
            score = Math.max(0, score + PENALTY_FOR_MISS); combo = 0; evidenceMissedCount++;
            addTapFeedback(item.x, item.y, 'Missed!', DISTRACTOR_COLOR, currentTime);
          }
          items.splice(i, 1);
        }
      }
      if (lives <= 0 && gameRunning) gameOver();
    }

    function updateScanner(deltaTime) {
      if (gamePaused) return;
      let scoreFactor = score * currentDifficultySetting.SCORE_SPEED_FACTOR;
      let dynamicSpeedMs = baseScannerSpeedMs * (1 + Math.min(scoreFactor, MAX_SCANNER_SPEED_INCREASE_FACTOR -1));
      currentScannerSpeedMs = focusModeActive ? dynamicSpeedMs * FOCUS_MODE_SPEED_MULTIPLIER : dynamicSpeedMs;
      
      scannerX += currentScannerSpeedMs * deltaTime * scannerDirection;

      // FIX 2: Scanner Bounce Logic
      if (scannerX + SCANNER_WIDTH / 2 >= screenWidth) {
        scannerX = screenWidth - SCANNER_WIDTH / 2; // Ensure it's visually at the edge
        scannerDirection = -1;
      } else if (scannerX - SCANNER_WIDTH / 2 <= 0) {
        scannerX = SCANNER_WIDTH / 2; // Ensure it's visually at the edge
        scannerDirection = 1;
      }
    }

    function createParticleExplosion(x,y,color,isError=false){ /* ... (same as V3) ... */const count=isError?15:25;const s=isError?2:3;for(let i=0;i<count;i++)particles.push({x,y,vx:getRandom(-s,s),vy:getRandom(-s,s),radius:getRandom(isError?3:2,isError?5:4),color:color.replace(/, [0-9\.]+\)/,`, ${getRandom(0.5,1)})`),lifespan:getRandom(300,600),spawnTime:performance.now(),alpha:1});}
    function updateParticles(deltaTime){ /* ... (same as V3) ... */for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx*(deltaTime/16);p.y+=p.vy*(deltaTime/16);p.alpha=Math.max(0,1-(performance.now()-p.spawnTime)/p.lifespan);p.vy+=0.05;if(p.alpha<=0)particles.splice(i,1);}}
    function drawParticles(){ /* ... (same as V3) ... */particles.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.radius*p.alpha,0,Math.PI*2);ctx.fillStyle=p.color.replace(/, [0-9\.]+\)/,`, ${p.alpha*0.8})`);ctx.fill();});}
    function drawIcon(type,x,y,radius,alpha){ /* ... (same as V3, ensure all icon types are covered) ... */ ctx.save();ctx.translate(x,y);ctx.globalAlpha=alpha;const iC=EVIDENCE_BASE_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha})`);ctx.lineWidth=2;ctx.strokeStyle=iC;ctx.fillStyle=iC;switch(type){case 'key':ctx.beginPath();ctx.arc(0,-radius*0.4,radius*0.3,0,Math.PI*2);ctx.moveTo(0,-radius*0.1);ctx.lineTo(0,radius*0.6);ctx.lineTo(radius*0.2,radius*0.6);ctx.moveTo(0,radius*0.3);ctx.lineTo(radius*0.2,radius*0.3);ctx.stroke();break;case 'phone':ctx.strokeRect(-radius*0.5,-radius*0.7,radius,radius*1.4);ctx.fillRect(-radius*0.3,-radius*0.55,radius*0.6,radius*0.15);ctx.beginPath();ctx.arc(0,radius*0.4,radius*0.1,0,Math.PI*2);ctx.fill();break;case 'footprint':ctx.beginPath();ctx.ellipse(0,0,radius*0.5,radius*0.8,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(0,-radius*0.6,radius*0.4,radius*0.3,Math.PI*0.1,0,Math.PI*2);ctx.fill();break;case 'document':ctx.strokeRect(-radius*0.6,-radius*0.7,radius*1.2,radius*1.4);for(let i=0;i<3;i++){ctx.beginPath();ctx.moveTo(-radius*0.45,-radius*0.4+i*radius*0.3);ctx.lineTo(radius*0.45,-radius*0.4+i*radius*0.3);ctx.stroke();}break;case 'sample':ctx.beginPath();ctx.moveTo(-radius*0.3,-radius*0.6);ctx.lineTo(-radius*0.3,radius*0.4);ctx.quadraticCurveTo(-radius*0.3,radius*0.7,0,radius*0.7);ctx.quadraticCurveTo(radius*0.3,radius*0.7,radius*0.3,radius*0.4);ctx.lineTo(radius*0.3,-radius*0.6);ctx.closePath();ctx.stroke();ctx.fillRect(-radius*0.2,-radius*0.1,radius*0.4,radius*0.5);break;case 'powerup_focus_icon':ctx.strokeStyle=POWERUP_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha})`);ctx.fillStyle=POWERUP_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha*0.5})`);ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,0,radius*0.5,0,Math.PI*2);ctx.lineWidth=1.5;ctx.stroke();break;case 'powerup_freeze_icon':ctx.strokeStyle=POWERUP_FREEZE_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha})`);ctx.fillStyle=POWERUP_FREEZE_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha*0.5})`);ctx.beginPath();for(let i=0;i<6;i++){ctx.moveTo(0,0);ctx.lineTo(Math.cos(i*Math.PI/3)*radius,Math.sin(i*Math.PI/3)*radius);ctx.moveTo(Math.cos(i*Math.PI/3+Math.PI/6)*radius*0.5,Math.sin(i*Math.PI/3+Math.PI/6)*radius*0.5);ctx.lineTo(Math.cos(i*Math.PI/3-Math.PI/6)*radius*0.5,Math.sin(i*Math.PI/3-Math.PI/6)*radius*0.5);}ctx.stroke();break;case 'distractor_icon':ctx.fillStyle=DISTRACTOR_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha*0.8})`);ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle='rgba(50,0,0,'+alpha+')';ctx.lineWidth=3;ctx.moveTo(-radius*0.5,-radius*0.5);ctx.lineTo(radius*0.5,radius*0.5);ctx.moveTo(radius*0.5,-radius*0.5);ctx.lineTo(-radius*0.5,radius*0.5);ctx.stroke();break;default:if(type==='fragment'){ctx.fillStyle=FRAGMENT_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha*0.7})`);ctx.strokeStyle=FRAGMENT_COLOR.replace(/, [0-9\.]+\)/,`, ${alpha})`);}ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2);ctx.fill();if(type==='fragment')ctx.stroke();break;}ctx.restore();}
    function drawBackground(){ /* ... (same as V3) ... */ backgroundHue=(backgroundHue+0.05)%360;document.body.style.backgroundColor=`hsl(${backgroundHue},30%,5%)`;ctx.fillStyle=`hsl(${backgroundHue},30%,10%)`;ctx.fillRect(0,0,screenWidth,screenHeight);if(focusModeActive)ctx.fillStyle='rgba(70,0,70,0.15)';else if(freezeModeActive)ctx.fillStyle='rgba(0,70,70,0.25)';if(focusModeActive||freezeModeActive)ctx.fillRect(0,0,screenWidth,screenHeight);}
    function drawScanner(){ /* ... (same as V3) ... */ let bC=SCANNER_COLOR_BASE;let gWM=2;if(combo>=HIGH_COMBO_THRESHOLD){bC=`rgba(255,255,0,0.8)`;gWM=3.5;}if(focusModeActive)bC=`rgba(255,0,255,0.8)`;else if(freezeModeActive)bC=`rgba(150,200,255,0.8)`;ctx.fillStyle=bC;ctx.fillRect(scannerX-SCANNER_WIDTH/2,0,SCANNER_WIDTH,screenHeight);const tSLB=performance.now()-lastBeatTime;const pP=gamePaused?0:Math.min(1,tSLB/currentBeatInterval);const pA=Math.sin(pP*Math.PI)*(focusModeActive?0.5:0.3);const pCRGB=combo>=HIGH_COMBO_THRESHOLD?'255,255,0':(focusModeActive?'255,0,255':(freezeModeActive?'150,200,255':'0,255,255'));ctx.fillStyle=`rgba(${pCRGB}, ${pA})`;ctx.fillRect(scannerX-SCANNER_WIDTH*gWM,0,SCANNER_WIDTH*gWM*2,screenHeight);}
    function drawItems(currentTime){ /* ... (same as V3, including shrinking effect) ... */ items.forEach(item=>{if(item.type==='fragment_parent')return;const tTE=(item.spawnTime+currentItemActiveDurationMs)-currentTime;let sF=1;if(tTE<currentItemActiveDurationMs&&tTE>0){sF=Math.max(0.3,tTE/currentItemActiveDurationMs);}else if(tTE<=0){sF=0.3;}const p=gamePaused?0.85:Math.sin((currentTime-item.spawnTime)/(currentBeatInterval/2.5)*Math.PI)*0.15+0.85;const cR=item.radius*p*item.alpha*sF;if(cR<1)return;if(item.iconType)drawIcon(item.iconType,item.x,item.y,cR,item.alpha);else drawIcon(item.type,item.x,item.y,cR,item.alpha);});}
    
    function drawUI() {
      ctx.fillStyle = '#E0E0E0';
      const fontSize = Math.max(18, screenWidth * 0.025);
      ctx.font = `${fontSize}px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
      ctx.textAlign = 'left';
      ctx.fillText(`Score: ${score}`, 20, fontSize*1.5);
      ctx.fillText(`Lives: ${lives}`, 20, fontSize*3);

      const comboBarWidth = screenWidth * 0.25;
      const comboBarHeight = fontSize * 0.8;
      const comboBarX = 20;
      const comboBarY = fontSize * 4.2;
      ctx.strokeStyle = '#E0E0E0'; ctx.lineWidth = 1;
      ctx.strokeRect(comboBarX, comboBarY, comboBarWidth, comboBarHeight);
      const comboProgress = Math.min(1, combo / MAX_COMBO_FOR_METER);
      ctx.fillStyle = combo >= HIGH_COMBO_THRESHOLD ? 'rgba(255,255,0,0.7)' : SCANNER_COLOR_BASE;
      ctx.fillRect(comboBarX + 1, comboBarY + 1, comboProgress * (comboBarWidth-2), comboBarHeight-2);

      ctx.textAlign = 'right';
      ctx.fillStyle = '#E0E0E0';
      ctx.fillText(`High Score: ${highScore}`, screenWidth-20, fontSize*1.5);
      if (combo > 1) {
        // FIX 7 (Bonus): Clearer Combo Meter Text (alpha increases with combo)
        const comboAlpha = Math.min(1, 0.3 + (combo * 0.07)); // Cap alpha at 1
        ctx.fillStyle = `rgba(0, 255, 255, ${comboAlpha})`; 
        ctx.fillText(`Combo: x${combo}`, screenWidth-20, fontSize*3);
      }
      // ... (rest of UI like focus/freeze mode text from V3)
      let bottomTextY = fontSize * 4.5; // Reference from V3
      if (focusModeActive) { 
          ctx.fillStyle = POWERUP_COLOR; ctx.textAlign = 'center';
          ctx.fillText(`FOCUS MODE!`, screenWidth/2, bottomTextY);
          const timeLeft = Math.max(0, (focusModeEndTime - performance.now()) / 1000).toFixed(1);
          ctx.font = `${fontSize*0.8}px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
          ctx.fillText(`${timeLeft}s`, screenWidth/2, bottomTextY + fontSize);
      } else if (freezeModeActive) {
          ctx.fillStyle = POWERUP_FREEZE_COLOR; ctx.textAlign = 'center';
          ctx.fillText(`FROZEN!`, screenWidth/2, bottomTextY);
          const timeLeft = Math.max(0, (freezeModeEndTime - performance.now()) / 1000).toFixed(1);
          ctx.font = `${fontSize*0.8}px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
          ctx.fillText(`${timeLeft}s`, screenWidth/2, bottomTextY + fontSize);
      }
    }

    function drawTapFeedback(currentTime){ /* ... (same as V3) ... */ for(let i=tapFeedback.length-1;i>=0;i--){const fb=tapFeedback[i];const age=currentTime-fb.spawnTime;const fadeDuration=900;if(age>fadeDuration){tapFeedback.splice(i,1);continue;}fb.alpha=1-(age/fadeDuration);const yPos=fb.y-(age/12);const currentScale=fb.scale*(1+(age/fadeDuration)*0.3);ctx.save();ctx.translate(fb.x,yPos);ctx.scale(currentScale,currentScale);ctx.font=`bold ${Math.max(18,screenWidth*0.022)}px Arial`;ctx.fillStyle=fb.color.replace(/, [0-9\.]+\)/,`, ${fb.alpha})`);ctx.textAlign='center';ctx.fillText(fb.text,0,0);ctx.restore();}}
    function drawStartScreen(){ /* ... (same as V3) ... */ drawBackground();ctx.fillStyle='#E0E0E0';ctx.textAlign='center';const tFS=Math.max(32,screenWidth*0.07);const sFS=Math.max(20,screenWidth*0.035);const dFS=Math.max(18,screenWidth*0.03);let yP=screenHeight*0.3;ctx.font=`bold ${tFS}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText("Evidence Lockdown V3.1",screenWidth/2,yP);yP+=tFS*1.2;ctx.font=`${sFS}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText("Tap Screen to Start Scan",screenWidth/2,yP);yP+=sFS*1.5;ctx.fillText(`High Score: ${highScore}`,screenWidth/2,yP);yP+=sFS*2;ctx.font=`bold ${dFS}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText(`Difficulty: ${difficultySelection[selectedDifficultyIndex]}`,screenWidth/2,yP);yP+=dFS*0.8;ctx.font=`${dFS*0.8}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText("(Tap area above to change)",screenWidth/2,yP);}
    function drawEndGameReport(){ /* ... (V3 logic + accuracy) ... */ ctx.fillStyle='rgba(10,10,10,0.85)';ctx.fillRect(0,0,screenWidth,screenHeight);ctx.fillStyle='#E0E0E0';ctx.textAlign='center';const titFS=Math.max(32,screenWidth*0.065);let yP=screenHeight*0.15;ctx.font=`bold ${titFS}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText("End of Shift Report",screenWidth/2,yP);yP+=titFS*1.5;const headFS=Math.max(20,screenWidth*0.035);ctx.font=`bold ${headFS}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText(`Final Score: ${score}`,screenWidth/2,yP);yP+=headFS*1.2;const detFS=Math.max(16,screenWidth*0.03);ctx.font=`${detFS}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;if(score>parseInt(localStorage.getItem('evidenceLockdownHighScoreV3')||"0")){ctx.fillText(`New High Score! (Old: ${localStorage.getItem('evidenceLockdownHighScoreV3')||"0"})`,screenWidth/2,yP);}else{ctx.fillText(`High Score: ${highScore}`,screenWidth/2,yP);}yP+=detFS*1.5;let accuracy=0;const successfulScans=evidenceCollectedCount+fragmentedSetsCompletedCount;const totalPossibleScans=totalEvidenceOpportunities;if(totalPossibleScans>0){accuracy=(successfulScans/totalPossibleScans)*100;}ctx.font=`bold ${Math.max(18,screenWidth*0.032)}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText(`Scan Accuracy: ${accuracy.toFixed(1)}%`,screenWidth/2,yP);yP+=Math.max(18,screenWidth*0.032)*1.5;ctx.textAlign='left';const c1X=screenWidth*0.15;const c2X=screenWidth*0.55;const dFS2=Math.max(16,screenWidth*0.028);ctx.font=`${dFS2}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;let rY=yP;ctx.fillText(`Evidence Scanned: ${evidenceCollectedCount}`,c1X,rY);rY+=dFS2*1.5;ctx.fillText(`Fragment Sets: ${fragmentedSetsCompletedCount}`,c1X,rY);rY+=dFS2*1.5;ctx.fillText(`Power-Ups Used: ${powerUpsCollectedCount}`,c1X,rY);rY=yP;ctx.fillText(`Contaminations: ${distractorsHitCount}`,c2X,rY);rY+=dFS2*1.5;ctx.fillText(`Missed Opportunities: ${evidenceMissedCount}`,c2X,rY);yP=Math.max(yP,rY)+dFS2*2.5;ctx.textAlign='center';ctx.font=`${Math.max(18,screenWidth*0.032)}px 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif`;ctx.fillText("Tap Screen to Restart",screenWidth/2,screenHeight*0.9);}

    let lastTime = 0;
    function gameLoop(currentTime) {
      // FIX 6 (Alternative): Ensure correct screen is drawn when not running (handled by resizeCanvas and specific calls in gameOver/init)
      if (!gameRunning && !freezeModeActive) {
        // Logic in resizeCanvas and specific calls in gameOver/init/startGame will handle drawing the correct screen
        return;
      }
      animationFrameId = requestAnimationFrame(gameLoop);

      const deltaTime = currentTime - lastTime;
      if(deltaTime > 100 && !freezeModeActive) {
          lastTime = currentTime; return;
      }
      lastTime = currentTime;

      if (focusModeActive && currentTime >= focusModeEndTime) deactivateFocusMode();
      if (freezeModeActive && currentTime >= freezeModeEndTime) deactivateFreezeMode();

      if (!gamePaused) {
        if (currentTime - lastBeatTime >= currentBeatInterval) {
            lastBeatTime = currentTime - ((currentTime - lastBeatTime) % currentBeatInterval);
            beatCount++;
            if (gameRunning) spawnItem(currentTime);
        }
        updateScanner(deltaTime);
        updateItems(currentTime, deltaTime);
      }
      updateParticles(deltaTime);

      draw();
      drawParticles();
      drawTapFeedback(currentTime);
    }

    function draw(){ /* ... (same as V3) ... */ ctx.clearRect(0,0,screenWidth,screenHeight);drawBackground();drawScanner();drawItems(performance.now());drawUI();}

    function startGame() {
      // FIX 3: Ensure animationFrameId is cancelled at the TOP
      if (animationFrameId) cancelAnimationFrame(animationFrameId);

      baseScannerSpeedMs = currentDifficultySetting.SCANNER_SPEED_MS;
      currentScannerSpeedMs = baseScannerSpeedMs;
      currentBeatInterval = 60000 / currentDifficultySetting.BPM;
      currentItemSpawnChance = currentDifficultySetting.SPAWN_CHANCE;
      currentItemActiveDurationMs = currentBeatInterval * currentDifficultySetting.ITEM_DURATION_BEATS;

      score = 0; combo = 0; lives = INITIAL_LIVES;
      items = []; tapFeedback = []; particles = []; beatCount = 0; itemIdCounter = 0;
      evidenceCollectedCount = 0; fragmentsCollectedCount = 0; fragmentedSetsCompletedCount = 0;
      distractorsHitCount = 0; evidenceMissedCount = 0; powerUpsCollectedCount = 0; totalEvidenceOpportunities = 0;

      deactivateFocusMode(); deactivateFreezeMode(); gamePaused = false;
      scannerX = SCANNER_WIDTH / 2; scannerDirection = 1;
      lastBeatTime = performance.now(); lastTime = performance.now();
      gameRunning = true;
      
      // animationFrameId will be set by the first call to gameLoop
      gameLoop(performance.now());
    }

    function gameOver() {
      gameRunning = false; gamePaused = false;
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      
      // FIX 4: High Score Type Safety (toString)
      if (score > parseInt(localStorage.getItem('evidenceLockdownHighScoreV3') || "0") ) {
          localStorage.setItem('evidenceLockdownHighScoreV3', score.toString());
          highScore = score;
      }
      drawEndGameReport();
    }

    function init() {
      // FIX 5: Taps Outside Canvas
      canvas.style.touchAction = 'none';
      document.body.style.touchAction = 'none'; // Suppress scrolling on mobile

      resizeCanvas(); // Initial draw and setup
      window.addEventListener('resize', resizeCanvas);
      canvas.addEventListener('mousedown', handleTap);
      canvas.addEventListener('touchstart', handleTap, { passive: false });
      
      highScore = parseInt(localStorage.getItem('evidenceLockdownHighScoreV3') || "0"); // Load high score
      drawStartScreen(); 
    }

    init();
  </script></body></html>
